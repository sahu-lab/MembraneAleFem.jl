<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Input · MembraneAleFem.jl</title><meta name="title" content="Input · MembraneAleFem.jl"/><meta property="og:title" content="Input · MembraneAleFem.jl"/><meta property="twitter:title" content="Input · MembraneAleFem.jl"/><meta name="description" content="Documentation for MembraneAleFem.jl."/><meta property="og:description" content="Documentation for MembraneAleFem.jl."/><meta property="twitter:description" content="Documentation for MembraneAleFem.jl."/><meta property="og:url" content="https://sahu-lab.github.io/MembraneAleFem.jl/man/input/"/><meta property="twitter:url" content="https://sahu-lab.github.io/MembraneAleFem.jl/man/input/"/><link rel="canonical" href="https://sahu-lab.github.io/MembraneAleFem.jl/man/input/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MembraneAleFem.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li class="is-active"><a class="tocitem" href>Input</a><ul class="internal"><li><a class="tocitem" href="#man-enums"><span>Enums.jl</span></a></li><li><a class="tocitem" href="#man-params"><span>Params.jl</span></a></li><li><a class="tocitem" href="#man-module-dof"><span>Dof.jl</span></a></li><li><a class="tocitem" href="#man-spline"><span>Spline.jl</span></a></li><li><a class="tocitem" href="#man-gauss-point"><span>GaussPoint.jl</span></a></li><li><a class="tocitem" href="#man-gp-basis-fn"><span>GpBasisFn.jl</span></a></li><li><a class="tocitem" href="#man-mesh"><span>Mesh.jl and Bc.jl</span></a></li><li><a class="tocitem" href="#man-input-jl"><span>Input.jl</span></a></li></ul></li><li><a class="tocitem" href="../analysis/">Analysis</a></li><li><a class="tocitem" href="../output/">Output</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Input</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Input</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sahu-lab/MembraneAleFem.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/main/docs/src/man/input.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="man-input"><a class="docs-heading-anchor" href="#man-input">Input</a><a id="man-input-1"></a><a class="docs-heading-anchor-permalink" href="#man-input" title="Permalink"></a></h1><p>The file <code>src/Input.jl</code> and files contained in <code>src/input/</code> are collectively referred to as the input module. Here, all calculations prior to the finite element analysis are carried out—including</p><ul><li>specification of the problem scenario, choice of mesh motion, and other parameters</li><li>generation of the finite element mesh</li><li>calculation of the basis functions and their derivatives</li><li>initialization of the surface position and degrees of freedom</li><li>application of boundary conditions</li></ul><p>All files below are in the <code>src/input/</code> directory.</p><h2 id="man-enums"><a class="docs-heading-anchor" href="#man-enums">Enums.jl</a><a id="man-enums-1"></a><a class="docs-heading-anchor-permalink" href="#man-enums" title="Permalink"></a></h2><p>The following enums are defined to simplify problem input.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.Scenario" href="#MembraneAleFem.Scenario"><code>MembraneAleFem.Scenario</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Scenario</code></pre><p>Scenarios to simulate: <code>instances(Scenario)</code></p><ul><li><code>F_CAVI = 1</code> –&gt; lid-driven cavity</li><li><code>F_COUE = 2</code> –&gt; Couette flow</li><li><code>F_POIS = 3</code> –&gt; Hagen–Poiseuille flow</li><li><code>F_PULL = 4</code> –&gt; tether pulling from a flat patch</li><li><code>F_BEND = 5</code> –&gt; bending of a flat patch</li></ul><p>The first letter indicates mesh <a href="#MembraneAleFem.Topology"><code>Topology</code></a>: <code>F</code> for a flat patch and <code>C</code> for a cylinder. At present, no cylindrical scenarios are implemented.</p><p>To create a new scenario:</p><ul><li>add and export a new entry in the <code>Scenario</code> enum</li><li>edit <a href="#MembraneAleFem.get_scenario_bc_info"><code>get_scenario_bc_info</code></a> in <code>src/input/Bc.jl</code></li><li>write the corresponding <code>apply_&lt;SCENARIO&gt;_bcs</code> function in <code>src/input/Mesh.jl</code> </li><li>add the new <code>scenario</code> to the <code>implemented</code> list in <code>src/input/Params.jl</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Enums.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.Topology" href="#MembraneAleFem.Topology"><code>MembraneAleFem.Topology</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Topology</code></pre><p>Mesh topologies: <code>instances(Topology)</code></p><ul><li><code>FLAT     = 1</code></li><li><code>CYLINDER = 2</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Enums.jl#L35-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.Motion" href="#MembraneAleFem.Motion"><code>MembraneAleFem.Motion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Motion</code></pre><p>Types of mesh motion: <code>instances(Motion)</code></p><ul><li><code>STATIC = 1</code> –&gt; mesh does not move</li><li><code>EUL    = 2</code> –&gt; Eulerian mesh motion</li><li><code>LAG    = 3</code> –&gt; Lagrangian mesh motion</li><li><code>ALEV   = 4</code> –&gt; ALE-viscous mesh motion</li><li><code>ALEVB  = 5</code> –&gt; ALE-viscous-bending mesh motion</li></ul><p>The choice of motion is stored in <code>Params.motion</code> variable in <a href="#man-params"><code>Params.jl</code></a>, and is relevant both to the specification of boundary conditions in <a href="#man-mesh"><code>Bc.jl</code></a> and the <a href="../analysis/#man-analysis">finite element analysis</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Enums.jl#L51-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.Boundary" href="#MembraneAleFem.Boundary"><code>MembraneAleFem.Boundary</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Boundary</code></pre><p>Enumerate four mesh boundaries: <code>instances(Boundary)</code>, never to be used as an index.</p><ul><li><code>BOTTOM = 1</code></li><li><code>RIGHT  = 2</code></li><li><code>TOP    = 3</code></li><li><code>LEFT   = 4</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Enums.jl#L78-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.Corner" href="#MembraneAleFem.Corner"><code>MembraneAleFem.Corner</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Corner</code></pre><p>Enumerate four mesh corners: <code>instances(Corner)</code>, never to be used as an index.</p><ul><li><code>BOTTOM_LEFT  = 1</code></li><li><code>BOTTOM_RIGHT = 2</code></li><li><code>TOP_LEFT     = 3</code></li><li><code>TOP_RIGHT    = 4</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Enums.jl#L99-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.Neumann" href="#MembraneAleFem.Neumann"><code>MembraneAleFem.Neumann</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Neumann</code></pre><p>Enumerate types of Neumann boundary conditions: <code>instances(Neumann)</code></p><ul><li><code>SHEAR     = 1</code> –&gt; apply in-plane force/length in the τ direction</li><li><code>STRETCH   = 2</code> –&gt; apply in-plane force/length in the ν direction</li><li><code>MOMENT    = 3</code> –&gt; apply boundary moment</li></ul><p>Associate finite element calculations are found in <a href="../analysis/#MembraneAleFem.calc_bdry_element_residual"><code>calc_bdry_element_residual</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Enums.jl#L119-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.Curve" href="#MembraneAleFem.Curve"><code>MembraneAleFem.Curve</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Curve</code></pre><p>Enumerate types of curves: <code>instances(Curve)</code></p><ul><li><code>CLAMPED</code></li><li><code>CLOSED</code></li></ul><p>These curves are used to generate B-spline basis functions—see <a href="#man-spline"><code>Spline.jl</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Enums.jl#L140-L150">source</a></section></article><h2 id="man-params"><a class="docs-heading-anchor" href="#man-params">Params.jl</a><a id="man-params-1"></a><a class="docs-heading-anchor-permalink" href="#man-params" title="Permalink"></a></h2><p>The requisite parameters for each simulation are split between the <a href="#MembraneAleFem.Params"><code>Params</code></a> struct and the keyword arguments <code>args</code>. The data contained in <a href="#MembraneAleFem.Params"><code>Params</code></a> is meant to be immutable, even across restarted (or continued) simulations. For this reason, temporal data (the initial time <code>t0</code>, initial time ID <code>t0_id</code>, and time steps <code>Δts</code>) is treated as a keyword argument, despite it being required for every simulation. Additional details about required keywords are contained in <a href="#MembraneAleFem.check_params"><code>check_params</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.Params" href="#MembraneAleFem.Params"><code>MembraneAleFem.Params</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Params</code></pre><p>Parameters that must be specified for any simulation.</p><p>For <a href="#MembraneAleFem.Scenario"><code>Scenario</code></a>-specific data that must be included via keyword arguments, see <a href="#MembraneAleFem.check_params"><code>check_params</code></a>. The following information is contained:</p><ul><li><code>motion::</code><a href="#MembraneAleFem.Motion"><code>Motion</code></a>     → type of motion</li><li><code>scenario::</code><a href="#MembraneAleFem.Scenario"><code>Scenario</code></a> → type of scenario</li><li><code>num1el::Int64</code>   → number of elements in <span>$ζ^1$</span></li><li><code>num2el::Int64</code>   → number of elements in <span>$ζ^2$</span></li><li><code>output::Bool</code>    → write output (yes by default)</li><li><code>length::Float64</code> → length, in real space</li><li><code>kb::Float64</code>     → mean bending modulus</li><li><code>kg::Float64</code>     → Gaussian bending modulus</li><li><code>ζv::Float64</code>     → membrane viscosity</li><li><code>pn::Float64</code>     → normal pressure (body force)</li><li><code>poly::Int64</code>     → polynomial order of basis functions</li><li><code>gp1d::Int64</code>     → number of Gauss points, in 1-D</li><li><code>nders::Int64</code>    → number of 1-D B-spline derivatives</li><li><code>nen::Int64</code>      → number of element nodes</li><li><code>αdb::Float64</code>    → Dohrmann–Bochev parameter</li><li><code>αm::Float64</code>     → mesh parameter</li><li><code>εk::Float64</code>     → tolerance numerical calculation of matrix K</li><li><code>εnr::Float64</code>    → Netwon–Raphson tolerance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Params.jl#L9-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.check_params" href="#MembraneAleFem.check_params"><code>MembraneAleFem.check_params</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_params(p::Params; args...)</code></pre><p>Check relevant parameters, including scenario-specific keyword arguments.</p><p>For any simulation, the fields <code>t0</code>, <code>t0_id</code>, and <code>Δts</code> are required. If data is output (as is the default, for <code>p.output</code>), the output path <code>out_path</code> and file name <code>out_file</code> are necessary. Finally, the information needed to solve the various <a href="#MembraneAleFem.Scenario"><code>Scenario</code></a>s is checked.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Params.jl#L59-L69">source</a></section></article><h2 id="man-module-dof"><a class="docs-heading-anchor" href="#man-module-dof">Dof.jl</a><a id="man-module-dof-1"></a><a class="docs-heading-anchor-permalink" href="#man-module-dof" title="Permalink"></a></h2><p>Within our ALE formalism, the membrane position <span>$\boldsymbol{x}$</span> is not a fundamental unknown. The mesh velocity <span>$\boldsymbol{v}^{\text{m}}$</span>, on the other hand, <em>is</em> a fundamental unknown, and over a time step <span>$\Delta t$</span> the membrane position is updated according to</p><p class="math-container">\[\boldsymbol{x} (\zeta^\alpha, t + \Delta t)
\, = \, \boldsymbol{x} (\zeta^\alpha, t)
\, + \, \Delta t \, \boldsymbol{v}^{\text{m}} (\zeta^\alpha, t + \Delta t)
~,\]</p><p>where <span>$\Delta t$</span> is one of the entries of the array <code>ΔTS</code> specified in <a href="#man-params"><code>Params.jl</code></a>. The membrane position is thus treated differently from the fundamental unknowns. For this reason, we define all <em>possible</em> fundamental unknowns and the three Cartesian components of the position in the <code>Dof</code> module:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.Dof.Unknown" href="#MembraneAleFem.Dof.Unknown"><code>MembraneAleFem.Dof.Unknown</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Dof.Unknown</code></pre><p>Possible degrees of freedom (or fundamental unknowns) at each node.</p><p>For different mesh motions, different fundamental unknowns are required. A Lagrangian simulation requires only <code>vx</code>, <code>vy</code>, <code>vz</code>, and <code>λ</code>, while an ALE simulation requires all eight fundamental unknowns. Currently, the mapping from the choice of <a href="#MembraneAleFem.Motion"><code>Motion</code></a> to the corresponding fundamental unknowns is specified in the function <a href="#MembraneAleFem.get_dofs"><code>get_dofs</code></a> and stored in <a href="#MembraneAleFem.Mesh"><code>Mesh</code></a><code>.dofs</code>.</p><p>This enum is encapsulated in a module; access elements with e.g. <code>Dof.vx</code>.</p><p>Types of fundamental unknowns:</p><ul><li><code>vx</code>  –&gt; <span>$x$</span>-velocity,      <span>$v_x$</span></li><li><code>vy</code>  –&gt; <span>$y$</span>-velocity,      <span>$v_y$</span></li><li><code>vz</code>  –&gt; <span>$z$</span>-velocity,      <span>$v_z$</span></li><li><code>vmx</code> –&gt; <span>$x$</span>-mesh velocity, <span>$v^{\text{m}}_x$</span></li><li><code>vmy</code> –&gt; <span>$y$</span>-mesh velocity, <span>$v^{\text{m}}_y$</span></li><li><code>vmz</code> –&gt; <span>$z$</span>-mesh velocity, <span>$v^{\text{m}}_z$</span></li><li><code>λ</code>   –&gt; surface tension,     <span>$λ$</span></li><li><code>pm</code>  –&gt; mesh pressure,       <span>$p^{\text{m}}$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Dof.jl#L4-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.Dof.Position" href="#MembraneAleFem.Dof.Position"><code>MembraneAleFem.Dof.Position</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Dof.Position</code></pre><p>Cartesian components of the mesh position at each node.</p><p>This enum is encapsulated in a module; access elements with e.g. <code>Dof.xm</code>.</p><p>Options:</p><ul><li><code>xm</code> –&gt; <span>$x$</span>-position</li><li><code>ym</code> –&gt; <span>$y$</span>-position</li><li><code>zm</code> –&gt; <span>$z$</span>-position</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Dof.jl#L37-L48">source</a></section></article><h2 id="man-spline"><a class="docs-heading-anchor" href="#man-spline">Spline.jl</a><a id="man-spline-1"></a><a class="docs-heading-anchor-permalink" href="#man-spline" title="Permalink"></a></h2><p>All B-spline calculations independent from finite element analysis, based entirely on <a href="https://doi.org/10.1007/978-3-642-97385-7"><strong>The NURBS Book</strong></a> (<a href="../../#piegl-tiller">Piegl and Tiller, 1997</a>). See in particular <em>Chapter Two</em> for a description of B-spline functions, and <em>Chapter Three</em> for an explanation of how the basis functions are used to generate 1D curves and 2D surfaces in <span>$\mathbb{R}^3$</span>. We employ the same terminology in our code.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.KnotVector" href="#MembraneAleFem.KnotVector"><code>MembraneAleFem.KnotVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KnotVector(ζs::Vector{Float64}, nel::Int64, poly::Int64, curve::Curve)</code></pre><p>Vector of knots, with which all 1-D B-spline functions are calculated.</p><p>The knot vector struct contains four fields:</p><ul><li><code>ζs</code> –&gt; list of all knots, including repeated ones</li><li><code>nel</code> –&gt; number of 1-D elements, or knot spans</li><li><code>poly</code> –&gt; polynomial order</li><li><code>curve</code> –&gt; type of <a href="#MembraneAleFem.Curve">Curve</a>, which is either <code>CLAMPED</code> or <code>CLOSED</code></li></ul><p>All of these data are not required to generate a knot vector. Two constructors are available—see <a href="#MembraneAleFem.knot_vector">knot_vector</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Spline.jl#L6-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.knot_vector" href="#MembraneAleFem.knot_vector"><code>MembraneAleFem.knot_vector</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">knot_vector(ζs::Vector{Float64}, poly::Int64, curve::Curve)</code></pre><p>External constructor of the <a href="#MembraneAleFem.KnotVector"><code>KnotVector</code></a> struct, where knots need not be uniform.</p><p>The list of knots <code>ζs</code>, polynomial order <code>poly</code>, and <a href="#MembraneAleFem.Curve"><code>Curve</code></a> type <code>curve</code> are passed in. If they represent a valid knot vector, then the struct is created.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Spline.jl#L36-L45">source</a></section><section><div><pre><code class="language-julia hljs">knot_vector(nel::Int64, poly::Int64, curve::Curve)</code></pre><p>External constructor of the <a href="#MembraneAleFem.KnotVector"><code>KnotVector</code></a> struct with uniform knots.</p><p>The number of elements <code>nel</code>, polynomial order <code>poly</code>, and <a href="#MembraneAleFem.Curve"><code>Curve</code></a> type <code>curve</code> are passed in. If the <code>curve</code> is <code>CLOSED</code>, then no knots are repeated. If the <code>curve</code> is <code>CLAMPED</code>, then the first and last <code>(poly+1)</code> knots are repeated. In both cases, the generated list of knots <code>ζs</code> ranges from 0 to 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Spline.jl#L64-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.get_knot_span_index" href="#MembraneAleFem.get_knot_span_index"><code>MembraneAleFem.get_knot_span_index</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_knot_span_index(kv::KnotVector, ζ::Float64)::Int64</code></pre><p>Return knot span index of <code>ζ</code> in <code>CLAMPED</code> or <code>CLOSED</code> <a href="#MembraneAleFem.KnotVector"><code>KnotVector</code></a> <code>kv</code>.</p><p>Algorithm A2.1 in Chap. 2, §5 of <a href="../../#piegl-tiller">Piegl and Tiller (1997)</a> ensures <code>kv.ζs[idx]</code> ≤ <code>ζ</code> &lt; <code>kv.ζs[idx+1]</code>, where <code>idx</code> is the returned value. The algorithm, valid only for <code>CLAMPED</code> knots, is here extended to <code>CLOSED</code> knots as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Spline.jl#L186-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.get_bspline_vals" href="#MembraneAleFem.get_bspline_vals"><code>MembraneAleFem.get_bspline_vals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_bspline_vals(kv::KnotVector, ζ::Float64)::Vector{Float64}</code></pre><p>Return <code>kv.poly</code>+1 nonzero B-spline functions at <code>ζ</code> for the given <a href="#MembraneAleFem.KnotVector"><code>KnotVector</code></a> <code>kv</code>.</p><p>Algorithm A2.2 in Chap. 2, §5 of <a href="../../#piegl-tiller">Piegl and Tiller (1997)</a>, valid for <code>CLAMPED</code> knot vectors with (<code>kv.poly</code>+1) repeated knots at the start and end, is also used for <code>CLOSED</code> knot vectors. The local-to-global mapping returned by <a href="#MembraneAleFem.get_bspline_indices"><code>get_bspline_indices</code></a> is necessary to determine which global basis functions are nonzero at the provided <code>ζ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Spline.jl#L251-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.get_bspline_ders" href="#MembraneAleFem.get_bspline_ders"><code>MembraneAleFem.get_bspline_ders</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_bspline_ders(kv::KnotVector, ζ::Float64, num_ders::Int64)::Matrix{Float64}</code></pre><p>Return B-spline functions and <code>num_ders</code> derivatives at <code>ζ</code> for the given <a href="#MembraneAleFem.KnotVector"><code>KnotVector</code></a> <code>kv</code>.</p><p>Algorithm A2.3 in Chap. 2, §5 of <a href="../../#piegl-tiller">Piegl and Tiller (1997)</a>, valid for <code>CLAMPED</code> knot vectors with (<code>kv.poly</code>+1) repeated knots at the start and end, is also used for <code>CLOSED</code> knot vectors. Here <code>num_ders</code> is required to not be greater than <code>kv.poly</code>, and also greater than or equal to zero. The local-to-global mapping returned by <a href="#MembraneAleFem.get_bspline_indices"><code>get_bspline_indices</code></a> is necessary to determine which global basis functions are nonzero at the provided <code>ζ</code>.</p><p>The returned matrix has <code>kv.poly</code>+1 rows and <code>num_ders</code>+1 columns. The first column contains the functions themselves, and is thus identical to the output of <a href="#MembraneAleFem.get_bspline_vals"><code>get_bspline_vals</code></a>. The second column contains the first derivatives, and so on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Spline.jl#L299-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.get_bspline_indices" href="#MembraneAleFem.get_bspline_indices"><code>MembraneAleFem.get_bspline_indices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_bspline_indices(kv::KnotVector, ζ::Float64)::Vector{Int64}</code></pre><p>Return global indices of nonzero B-splines at the value <code>ζ</code> in the <a href="#MembraneAleFem.KnotVector"><code>KnotVector</code></a> <code>kv</code>.</p><p>By definition, there are only <code>kv.poly</code>+1 nonzero B-spline functions at any <code>ζ</code>. The functions <a href="#MembraneAleFem.get_bspline_vals"><code>get_bspline_vals</code></a> and <a href="#MembraneAleFem.get_bspline_ders"><code>get_bspline_ders</code></a> calculate these nonzero quantities, and the mapping returned here places them within the global ordering. The global indices are the same for all <code>ζ</code> within a single knot span, and thus we begin by calling <a href="#MembraneAleFem.get_knot_span_index"><code>get_knot_span_index</code></a>.</p><p>Both <code>CLAMPED</code> knot vectors, with (<code>kv.poly</code>+1) repeats at the start and end, as well as <code>CLOSED</code> knot vectors, are handled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Spline.jl#L425-L440">source</a></section><section><div><pre><code class="language-julia hljs">get_bspline_indices(kv::KnotVector, ks_id::Int64)::Vector{Int64}</code></pre><p>Return global indices of nonzero B-splines at <code>ks_id</code><span>$^{\textrm{th}}$</span> knot span in the <a href="#MembraneAleFem.KnotVector"><code>KnotVector</code></a> <code>kv</code>.</p><p>By definition, there are only <code>kv.poly</code>+1 nonzero B-spline functions over any knot span. The mapping returned here places these functions within the global ordering. Both <code>CLAMPED</code> knot vectors, with (<code>kv.poly</code>+1) repeats at the start and end, as well as <code>CLOSED</code> knot vectors, are handled. Note that <code>ks_id</code> is <em>not</em> the element ID <code>eid</code>; rather, <code>ks_id = eid + kv.poly</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Spline.jl#L452-L464">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.get_1d_bspline_cps" href="#MembraneAleFem.get_1d_bspline_cps"><code>MembraneAleFem.get_1d_bspline_cps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_1d_bspline_cps(kv::KnotVector, x::Function)::Vector{Float64}</code></pre><p>Return the global control points <span>$\{ x^{}_K \}$</span> for the function <span>$x(ζ)$</span>.</p><p>The global control points <span>$\{ x^{}_K \}$</span> are calculated for the provided <a href="#MembraneAleFem.KnotVector"><code>KnotVector</code></a> <code>kv</code> such that</p><p class="math-container">\[x(ζ)
\, \approx \, \sum_{K = 1}^{\texttt{nn}} N^{}_K (ζ) \, x^{}_K
~,\]</p><p>where <span>$x(ζ)$</span> is the provided <code>x::Function</code> and here <span>$\texttt{nn}$</span> is the number of global 1-D nodes. To determine the unknown <span>$\{ x^{}_K \}$</span>, a set of <span>$\texttt{nn}$</span> collocation points <span>$\{ ζ^{}_J \}$</span> is chosen via <a href="#MembraneAleFem.collocate_ζ"><code>collocate_ζ</code></a>. A matrix equation is then obtained as</p><p class="math-container">\[[x (ζ^{}_J)]
\, = \, [N^{}_K (ζ^{}_J)] \, [x^{}_K]
~,\]</p><p>where the <span>$N^{}_K (ζ^{}_J)$</span> are determined with <a href="#MembraneAleFem.get_bspline_indices"><code>get_bspline_indices</code></a> and <a href="#MembraneAleFem.get_bspline_vals"><code>get_bspline_vals</code></a>. The <span>$x^{}_K$</span> are then calculated and returned as a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Spline.jl#L484-L509">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.get_2d_bspline_cps" href="#MembraneAleFem.get_2d_bspline_cps"><code>MembraneAleFem.get_2d_bspline_cps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_2d_bspline_cps(kv1::KnotVector, kv2::KnotVector, x::Function)::Matrix{Float64}</code></pre><p>Return the global control points <span>$\{ x^{}_K \}$</span> for the scalar-valued function <span>$z(ζ^1, ζ^2)$</span>.</p><p>The procedure of <a href="#MembraneAleFem.get_1d_bspline_cps"><code>get_1d_bspline_cps</code></a> is repeated, except in this case collocation points are chosen across the 2-D parametric domain <span>$(ζ^1, ζ^2)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Spline.jl#L531-L539">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.collocate_ζ" href="#MembraneAleFem.collocate_ζ"><code>MembraneAleFem.collocate_ζ</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">collocate_ζ(kv::KnotVector)::Vector{Float64}</code></pre><p>Take a <a href="#MembraneAleFem.KnotVector"><code>KnotVector</code></a> <code>kv</code> and return a list of points <code>ζ</code> used for collocation.</p><p>The length of the returned list of ζ values is equal to the number of global basis functions associated with the provided knot vector. Both <code>CLAMPED</code> and <code>CLOSED</code> knot vectors are accounted for.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Spline.jl#L570-L579">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.get_unique_1d_elements" href="#MembraneAleFem.get_unique_1d_elements"><code>MembraneAleFem.get_unique_1d_elements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_unique_1d_elements(kv::KnotVector)</code></pre><p>Get all unique elements for a given knot vector <code>kv</code>.</p><p>This function returns several quantities, in the following order:</p><ul><li><code>uel_num::Int64</code> -&gt; number of unique elements</li><li><code>num_el::Int64</code> -&gt; number of elements</li><li><code>uel_ids::Vector{Int64}</code> -&gt; mapping from element id to unique element id</li><li><code>uel_list::Vector{Tuple{Float64, Float64}}</code> -&gt; start and end <code>ζ</code> for each unique element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Spline.jl#L629-L639">source</a></section></article><h2 id="man-gauss-point"><a class="docs-heading-anchor" href="#man-gauss-point">GaussPoint.jl</a><a id="man-gauss-point-1"></a><a class="docs-heading-anchor-permalink" href="#man-gauss-point" title="Permalink"></a></h2><p>As is standard in finite element analysis, Gauss–Legendre quadrature is used to approximate integrals over the parametric domain. Here, the primary objective is to calculate the 1-D integral</p><p class="math-container">\[I_1
\, = \, \int_{ζ_{\texttt{lo}}}^{ζ_{\texttt{hi}}} \!\!\! f(ζ) \, \text{d} ζ
~.\]</p><p>The domain of integration is mapped from <span>$[ ζ_{\texttt{lo}}, ζ_{\texttt{hi}} ]$</span> to <span>$[-1, +1]$</span> via the change of variables</p><p class="math-container">\[ζ
\, = \, \dfrac{1}{2} \, ξ \, \big(
	ζ_{\texttt{hi}}
	- ζ_{\texttt{lo}}
\big)
\, + \, \dfrac{1}{2} \, \big(
	ζ_{\texttt{hi}}
	+ ζ_{\texttt{lo}}
\big)
~,\]</p><p>for which the integral <span>$I_1$</span> is equivalently given by</p><p class="math-container">\[I_1
\, = \, \dfrac{1}{2} \, \big(
	ζ_{\texttt{hi}}
	- ζ_{\texttt{lo}}
\big) \int_{-1}^{+1} \!\! f \bigg(
	\dfrac{1}{2} \Big[
		ξ \big(
			ζ_{\texttt{hi}}
			- ζ_{\texttt{lo}}
		\big)
		+ \big(
			ζ_{\texttt{hi}}
			+ ζ_{\texttt{lo}}
		\big)
	\Big]
\bigg) \, \text{d} ξ
\, = \, \dfrac{1}{2} \, \big(
	ζ_{\texttt{hi}}
	- ζ_{\texttt{lo}}
\big) \int_{-1}^{+1} \!\! \hat{f} (ξ) \, \text{d} ξ
~.\]</p><p>At this point, the integral is approximated by applying the Gaussian quadrature formula</p><p class="math-container">\[I_1
\, ≈ \, \dfrac{1}{2} \, \big(
	ζ_{\texttt{hi}}
	- ζ_{\texttt{lo}}
\big) \, \sum_{k = 1}^{\texttt{ngp}} \hat{w}_k \, \hat{f} (ξ_k)
~,\]</p><p>where <span>$\texttt{ngp}$</span> is the number of 1D Gauss points, <span>$\hat{w}_k$</span> are the corresponding weights, and <span>$ξ_k$</span> are the associated Gauss–Legendre points. In our code, <a href="#MembraneAleFem.GaussPointsξ"><code>GaussPointsξ</code></a> contains <span>$\texttt{ngp}$</span>, <span>$\hat{w}_k$</span>, and <span>$ξ_k$</span>. Note that this <code>struct</code> is the same for every line element, because  <span>$ξ ∈ [-1, +1]$</span> always.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.GaussPointsξ" href="#MembraneAleFem.GaussPointsξ"><code>MembraneAleFem.GaussPointsξ</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussPointsξ(ngp::Int64)</code></pre><p>Weights <span>$\hat{w}_k$</span> and points <span>$ξ_k$</span> on the interval <span>$[-1, +1]$</span> with which a 1-D integral is approximated.</p><p>The struct has three fields:</p><ul><li><code>ngp</code> –&gt; number of Gaussian quadrature points</li><li><code>ξs</code>  –&gt; set of points <span>$ξ_k$</span></li><li><code>ws</code>  –&gt; set of weights <span>$\hat{w}_k$</span></li></ul><p>Calculations from <a href="https://en.wikipedia.org/wiki/Gaussian_quadrature#Gauss.E2.80.93Legendre_quadrature">Wikipedia: Gaussian quadrature</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/GaussPoint.jl#L6-L17">source</a></section></article><p>In our finite element implementation, it is often convenient to evaluate integrals over the original variable <code>ζ</code> rather than the transformed variable <code>ξ</code>. To this end, we recognize that</p><p class="math-container">\[I_1
\, ≈ \, \sum_{k = 1}^{\texttt{ngp}} w_k \, f (ζ_k)
~,\]</p><p>where</p><p class="math-container">\[w_k
\, := \,\dfrac{1}{2} \, \hat{w}_k \, \big(
	ζ_{\texttt{hi}}
	- ζ_{\texttt{lo}}
\big)
\qquad
\text{and}
\qquad
ζ_k
\, := \, \dfrac{1}{2} \Big[
	ξ_k \big(
		ζ_{\texttt{hi}}
		- ζ_{\texttt{lo}}
	\big)
	+ \big(
		ζ_{\texttt{hi}}
		+ ζ_{\texttt{lo}}
	\big)
\Big]
~.\]</p><p>In our code, <a href="#MembraneAleFem.GaussPointsζ"><code>GaussPointsζ</code></a> contains <code>ngp</code>, <span>$w_k$</span>, and <span>$ζ_k$</span>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.GaussPointsζ" href="#MembraneAleFem.GaussPointsζ"><code>MembraneAleFem.GaussPointsζ</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussPointsζ(gpsξ::GaussPointsξ, ζlo::Float64, ζhi::Float64)</code></pre><p>Weights <span>$w_k$</span> and points <span>$ζ_k$</span> with which a 1-D integral is approximated over <code>ζlo</code> ≤ <code>ζ</code> ≤ <code>ζhi</code>.</p><p>Calculated via the transform from <code>ξ</code> to <code>ζ</code> via the relations</p><p><code>ζ</code><span>$_k$</span> = <code>ξ</code><span>$_k$</span> (<code>ζhi</code> - <code>ζlo</code>) / 2 + (<code>ζhi</code> + <code>ζlo</code>) / 2</p><p><span>$w_k$</span> = <span>$\hat{w}_k$</span> (<code>ζhi</code> - <code>ζlo</code>) / 2</p><p>The struct has three fields:</p><ul><li><code>ngp</code> –&gt; number of Gaussian quadrature points</li><li><code>ζs</code>  –&gt; set of points <span>$ζ_k$</span></li><li><code>ws</code>  –&gt; set of weights <span>$w_k$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/GaussPoint.jl#L50-L66">source</a></section></article><h2 id="man-gp-basis-fn"><a class="docs-heading-anchor" href="#man-gp-basis-fn">GpBasisFn.jl</a><a id="man-gp-basis-fn-1"></a><a class="docs-heading-anchor-permalink" href="#man-gp-basis-fn" title="Permalink"></a></h2><p>Calculation of nonzero B-spline basis functions at every Gaussian quadrature point. Since the basis functions are determined upon discretizing the parametric domain, they are calculated once and then stored in the structs listed below—which systematically build up in complexity.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.GpBasisFnsζ" href="#MembraneAleFem.GpBasisFnsζ"><code>MembraneAleFem.GpBasisFnsζ</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GpBasisFnsζ(gpwζ::Float64, ζ::Float64, kv::KnotVector)</code></pre><p>1-D basis functions <span>$N(ζ)$</span> at the provided quadrature point <code>ζ</code> with weight <code>gpwζ</code>.</p><p>The B-spline values and derivatives are determined with <a href="#MembraneAleFem.get_bspline_ders"><code>get_bspline_ders</code></a> and stored here. The struct contains four fields:</p><ul><li><code>w</code>   –&gt; Gauss point weight, passed in as <code>gpw</code></li><li><code>N</code>   –&gt; (<code>poly</code>+1)×1 vector of nonzero basis functions <span>$N(ζ)$</span></li><li><code>dN</code>  –&gt; (<code>poly</code>+1)×1 vector of nonzero first derivatives <span>$N&#39;(ζ)$</span></li><li><code>ddN</code> –&gt; (<code>poly</code>+1)×1 vector of nonzero second derivatives <span>$N&#39;&#39;(ζ)$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/GpBasisFn.jl#L6-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.GpBasisFnsζα" href="#MembraneAleFem.GpBasisFnsζα"><code>MembraneAleFem.GpBasisFnsζα</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GpBasisFnsζα(fns1::GpBasisFnsζ, fns2::GpBasisFnsζ)</code></pre><p>2-D basis functions <span>$N(ζ^α)$</span> at a single Gauss point <span>$ζ^α$</span>, as set by 1-D <a href="#MembraneAleFem.GpBasisFnsζ"><code>GpBasisFnsζ</code></a> <code>fns1</code> and <code>fns2</code>.</p><p>Here <span>$ζ^1$</span> and <span>$ζ^2$</span> respectively correspond to the <code>ζ</code> values passed to <code>fns1</code> and <code>fns2</code>, even though this information is not stored. The 2-D basis functions are calculated as the tensor product of 1-D functions. The struct contains four fields:</p><ul><li><code>w</code> –&gt; Gauss point weight, given by <code>fns1.w × fns2.w</code></li><li><code>N</code> –&gt; <code>NEN</code>×1 vector of nonzero basis functions <span>$N(ζ^α)$</span>, ordered by the tensor product structure</li><li><code>∂Nα</code> –&gt; <code>NEN</code>×2 matrix of first derivatives: rows respectively contain <span>$N_{, 1}$</span> and <span>$N_{, 2}$</span></li><li><code>∂∂Nαβ</code> –&gt; <code>NEN</code>×3 matrix of second derivatives: rows respectively contain <span>$N_{, 1 1}$</span>, <span>$N_{, 2 2}$</span>, and <span>$N_{, 1 2}$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/GpBasisFn.jl#L78-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.LineGpBasisFns" href="#MembraneAleFem.LineGpBasisFns"><code>MembraneAleFem.LineGpBasisFns</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LineGpBasisFns(kv::KnotVector, ngp::Int64)</code></pre><p>1-D B-spline basis functions and derivatives at all quadrature points on the domain of the <a href="#MembraneAleFem.KnotVector"><code>KnotVector</code></a> <code>kv</code>.</p><p>Basis functions are determined at each of the <code>ngp</code> Gauss points, over each element. When using B-splines, scenarios often arise where the basis functions are identical across many elements. We accordingly store only the 1-D basis functions over unique elements, as well as a mapping from elements to unique elements. The basis functions at the edges of the 1-D parametric domain are stored separately, as they are required subsequently for application of boundary conditions. The struct has five fields:</p><ul><li><code>nel</code> –&gt; number of elements in the <a href="#MembraneAleFem.KnotVector"><code>KnotVector</code></a> <code>kv</code></li><li><code>uel_ids</code> –&gt; mapping from <code>elem_id</code> to <code>unique_elem_id</code></li><li><code>ufns</code> –&gt; <code>num_unique_elems</code>×<code>ngp</code> matrix of unique 1-D basis functions, of type <a href="#MembraneAleFem.GpBasisFnsζ"><code>GpBasisFnsζ</code></a></li><li><code>ζmin_fns</code> –&gt; 1-D basis functions at the min value of the parametric domain</li><li><code>ζmax_fns</code> –&gt; 1-D basis functions at the max value of the parametric domain</li></ul><p>Note that this struct contains no information about how basis functions vary in the orthogonal parametric direction, and thus cannot be directly used to apply boundary conditions. See <a href="#MembraneAleFem.BdryGpBasisFns"><code>BdryGpBasisFns</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/GpBasisFn.jl#L115-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.BdryGpBasisFns" href="#MembraneAleFem.BdryGpBasisFns"><code>MembraneAleFem.BdryGpBasisFns</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BdryGpBasisFns(line_gp_fns::LineGpBasisFns, perp_edge_fns::GpBasisFnsζ, bdry::Boundary)</code></pre><p>2-D B-spline basis functions and derivatives at all quadrature points on a boundary.</p><p>The <a href="#MembraneAleFem.LineGpBasisFns"><code>LineGpBasisFns</code></a> struct <code>line_gp_fns</code> contains all 1-D basis functions and derivatives along the boundary, with <code>ngp</code> Gauss points for each element. Here <code>perp_edge_fns</code> are the basis functions and derivatives at the boundary in the orthogonal parametric direction, as contained in a <a href="#MembraneAleFem.GpBasisFnsζ"><code>GpBasisFnsζ</code></a> struct. For example, on the <code>RIGHT</code> boundary, <code>line_gp_fns</code> captures 1-D derivatives in the <span>$ζ^2$</span> direction, while <code>perp_edge_fns</code> contains 1-D derivatives in the <span>$ζ^1$</span> direction on the right edge. With knowledge of the underlying tensor product structure (<a href="../../#piegl-tiller">Piegl and Tiller, 1997</a>), the 2-D basis functions along the specified <a href="#MembraneAleFem.Boundary"><code>Boundary</code></a> <code>bdry</code> are generated. The struct has four fields:</p><ul><li><code>nel</code> –&gt; number of elements associated with <a href="#MembraneAleFem.LineGpBasisFns"><code>LineGpBasisFns</code></a> <code>line_gp_fns</code></li><li><code>uel_ids</code> –&gt; mapping from <code>elem_id</code> to <code>unique_elem_id</code></li><li><code>ufns</code> –&gt; <code>num_unique_elems</code>×<code>ngp</code> matrix of unique 2-D basis functions, of type <a href="#MembraneAleFem.GpBasisFnsζα"><code>GpBasisFnsζα</code></a></li><li><code>bdry</code> –&gt; <a href="#MembraneAleFem.Boundary"><code>Boundary</code></a> of the parametric domain</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/GpBasisFn.jl#L205-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.AreaGpBasisFns" href="#MembraneAleFem.AreaGpBasisFns"><code>MembraneAleFem.AreaGpBasisFns</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AreaGpBasisFns(line_gp_fns1::LineGpBasisFns, line_gp_fns2::LineGpBasisFns)</code></pre><p>2-D B-spline basis functions and derivatives at all quadrature points in the mesh area.</p><p>The two <a href="#MembraneAleFem.LineGpBasisFns"><code>LineGpBasisFns</code></a> structs passed in, <code>line_gp_fns1</code> and <code>line_gp_fns2</code>, respectively contain 1-D derivatives in the <span>$ζ^1$</span> and <span>$ζ^2$</span> directions. With the tensor product structure of B-splines over a surface (<a href="../../#piegl-tiller">Piegl and Tiller, 1997</a>), it is straightforward to calculate the 2-D basis functions and their derivatives. As is the case for <a href="#MembraneAleFem.LineGpBasisFns"><code>LineGpBasisFns</code></a>, a mapping from elements to unique elements is generated; only unique basis function calculations are stored. This struct has three fields:</p><ul><li><code>nel</code> –&gt; number of area elements</li><li><code>uel_ids</code> –&gt; mapping from <code>elem_id</code> to <code>unique_elem_id</code></li><li><code>ufns</code> –&gt; <code>num_unique_elems</code>×<code>ngp</code> matrix of unique 2-D basis functions, of type <a href="#MembraneAleFem.GpBasisFnsζα"><code>GpBasisFnsζα</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/GpBasisFn.jl#L280-L299">source</a></section></article><h2 id="man-mesh"><a class="docs-heading-anchor" href="#man-mesh">Mesh.jl and Bc.jl</a><a id="man-mesh-1"></a><a class="docs-heading-anchor-permalink" href="#man-mesh" title="Permalink"></a></h2><p>The mesh is one of the main constructions required for finite element analysis. In this codebase, the functions associated with mesh generation are divided into two files. <code>Mesh.jl</code> deals with aspects of mesh generation that are independent of the scenario under consideration, while <code>Bc.jl</code> handles the boundary conditions and their effect on mesh organization—which is scenario-dependent.</p><h3 id="Mesh.jl"><a class="docs-heading-anchor" href="#Mesh.jl">Mesh.jl</a><a id="Mesh.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh.jl" title="Permalink"></a></h3><p>All relevant information is contained in the <a href="#MembraneAleFem.Mesh"><code>Mesh</code></a> struct, and will not change over the course of a simulation.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.Mesh" href="#MembraneAleFem.Mesh"><code>MembraneAleFem.Mesh</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Mesh(p::Params; args...)</code></pre><p>The generated mesh, which includes the degree-of-freedom numbering and all basis functions for the given <a href="#MembraneAleFem.Scenario"><code>Scenario</code></a>.</p><p>This struct contains the following scenario-independent fields:</p><ul><li><code>num1el</code> –&gt; number of elements in <span>$ζ^1$</span> direction</li><li><code>num2el</code> –&gt; number of elements in <span>$ζ^2$</span> direction</li><li><code>numel</code> –&gt; number of area elements</li><li><code>num1np</code> –&gt; number of nodal points in <span>$ζ^1$</span> direction</li><li><code>num2np</code> –&gt; number of nodal points in <span>$ζ^2$</span> direction</li><li><code>numnp</code> –&gt;  number of nodal points on the 2-d mesh</li><li><code>IX</code> –&gt; matrix containing nonzero node numbers for each area element</li><li><code>bdry_elems</code> –&gt; mapping from <a href="#MembraneAleFem.Boundary"><code>Boundary</code></a> to element numbers</li><li><code>crnr_elems</code> –&gt; mapping from <a href="#MembraneAleFem.Corner"><code>Corner</code></a> to element number</li><li><code>bdry_nodes</code> –&gt; mapping from <a href="#MembraneAleFem.Boundary"><code>Boundary</code></a> to node numbers</li><li><code>bdry_inner_nodes</code> –&gt; mapping from <a href="#MembraneAleFem.Boundary"><code>Boundary</code></a> to inner node numbers</li><li><code>crnr_nodes</code> –&gt; mapping from <a href="#MembraneAleFem.Corner"><code>Corner</code></a> to node number</li><li><code>crnr_inner_nodes</code> –&gt; mapping from <a href="#MembraneAleFem.Corner"><code>Corner</code></a> to inner node number</li><li><code>kv1</code> –&gt; <a href="#MembraneAleFem.KnotVector"><code>KnotVector</code></a> along <span>$ζ^1$</span> direction</li><li><code>kv2</code> –&gt; <a href="#MembraneAleFem.KnotVector"><code>KnotVector</code></a> along <span>$ζ^2$</span> direction</li><li><code>area_gp_fns</code> –&gt; <a href="#MembraneAleFem.AreaGpBasisFns"><code>AreaGpBasisFns</code></a>: 2-D area basis functions</li><li><code>bdry_gp_fns</code> –&gt; mapping from <a href="#MembraneAleFem.Boundary"><code>Boundary</code></a> to <a href="#MembraneAleFem.BdryGpBasisFns"><code>BdryGpBasisFns</code></a></li><li><code>crnr_gp_fns</code> –&gt; mapping from <a href="#MembraneAleFem.Corner"><code>Corner</code></a> to 2-D basis functions <a href="#MembraneAleFem.GpBasisFnsζα"><code>GpBasisFnsζα</code></a></li></ul><p>The generated mesh depends on the problem being solved. The function <a href="#MembraneAleFem.generate_scenario"><code>generate_scenario</code></a> uses the scenario-specific results from <code>Bc.jl</code> to set the following scenario-dependent fields:</p><ul><li><code>topology</code> –&gt; surface <a href="#MembraneAleFem.Topology"><code>Topology</code></a></li><li><code>dofs</code> –&gt; list of active <a href="#MembraneAleFem.Dof.Unknown"><code>Unknown</code></a>s with global ordering</li><li><code>ndf</code> –&gt; number of active <a href="#MembraneAleFem.Dof.Unknown"><code>Unknown</code></a>s</li><li><code>ID</code> –&gt; matrix mapping node number to indices of unknowns at that node</li><li><code>ID_inv</code> –&gt; inverse of <code>ID</code>: map <code>unknown_id</code> to <code>(node_number, dof_number)</code></li><li><code>nmdf</code> –&gt; total number of mesh degrees of freedom</li><li><code>LM</code> –&gt; map from area element to indices of all unknowns of that element</li><li><code>inh_dir_bcs</code> –&gt; list of inhomogeneous Dirichlet boundary conditions</li><li><code>inh_neu_bcs</code> –&gt; list of inhomogeneous Neumann boundary conditions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Mesh.jl#L7-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.generate_scenario" href="#MembraneAleFem.generate_scenario"><code>MembraneAleFem.generate_scenario</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_scenario(numel, numnp, IX, bdry_nodes, ..., p::Params; args...)</code></pre><p>Apply scenario-specific boundary conditions towards mesh generation.</p><p>Checks to see whether a helper function is available in <code>Bc.jl</code> for the given <a href="#MembraneAleFem.Scenario"><code>Scenario</code></a>, and then constructs the <code>ID</code> matrix that maps from nodes to global degrees of freedom. The inverse <code>ID_inv</code> is also generated, as is the <code>LM</code> matrix—which provides the local degrees of freedom for each element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Mesh.jl#L251-L261">source</a></section></article><p>The following helper functions allow the user to easily obtain basis functions, their derivatives, and Gauss point weights both in the mesh interior and on the mesh boundary.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.get_basis_fns" href="#MembraneAleFem.get_basis_fns"><code>MembraneAleFem.get_basis_fns</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_basis_fns(el_id::Int64, gp_id::Int64, mesh::Mesh)::GpBasisFnsζα</code></pre><p>Return <a href="#MembraneAleFem.GpBasisFnsζα"><code>GpBasisFnsζα</code></a> of the <code>gp_id</code><span>$^{\text{th}}$</span> 2-D Gauss point of the <code>el_id</code><span>$^{\text{th}}$</span> area element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Mesh.jl#L305-L310">source</a></section><section><div><pre><code class="language-julia hljs">get_basis_fns(bdry::Boundary, el_id::Int64, gp_id::Int64, mesh::Mesh)::GpBasisFnsζα</code></pre><p>Return <a href="#MembraneAleFem.GpBasisFnsζα"><code>GpBasisFnsζα</code></a> of the <code>gp_id</code><span>$^{\text{th}}$</span> 1-D Gauss point of the <code>el_id</code><span>$^{\text{th}}$</span> element on the <a href="#MembraneAleFem.Boundary"><code>Boundary</code></a> <code>bdry</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Mesh.jl#L384-L389">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.get_gpw" href="#MembraneAleFem.get_gpw"><code>MembraneAleFem.get_gpw</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_gpw(el_id::Int64, gp_id::Int64, mesh::Mesh)::Float64</code></pre><p>Return the Gauss point weight of the call to <a href="#MembraneAleFem.get_basis_fns"><code>get_basis_fns</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Mesh.jl#L322-L326">source</a></section><section><div><pre><code class="language-julia hljs">get_gpw(bdry::Boundary, el_id::Int64, gp_id::Int64, mesh::Mesh)::Vector{Float64}</code></pre><p>Return the Gauss point weight of the call to <a href="#MembraneAleFem.get_basis_fns"><code>get_basis_fns</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Mesh.jl#L406-L410">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.get_N" href="#MembraneAleFem.get_N"><code>MembraneAleFem.get_N</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_N(el_id::Int64, gp_id::Int64, mesh::Mesh)::SVector{NEN,Float64}</code></pre><p>Return local basis functions <span>$[𝐍^e]$</span> of the call to <a href="#MembraneAleFem.get_basis_fns"><code>get_basis_fns</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Mesh.jl#L337-L341">source</a></section><section><div><pre><code class="language-julia hljs">get_N(bdry::Boundary, el_id::Int64, gp_id::Int64, mesh::Mesh)</code></pre><p>Return local basis functions <span>$[𝐍^e]$</span> of the call to <a href="#MembraneAleFem.get_basis_fns"><code>get_basis_fns</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Mesh.jl#L422-L426">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.get_∂Nα" href="#MembraneAleFem.get_∂Nα"><code>MembraneAleFem.get_∂Nα</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_∂Nα(el_id::Int64, gp_id::Int64, mesh::Mesh)::SMatrix{NEN,ζDIM,Float64}</code></pre><p>Return local basis function derivatives <span>$[𝐍^e]_{, α}$</span> of the call to <a href="#MembraneAleFem.get_basis_fns"><code>get_basis_fns</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Mesh.jl#L352-L357">source</a></section><section><div><pre><code class="language-julia hljs">get_∂Nα(bdry::Boundary, el_id::Int64, gp_id::Int64, mesh::Mesh)</code></pre><p>Return local basis function derivatives <span>$[𝐍^e]_{, α}$</span> of the call to <a href="#MembraneAleFem.get_basis_fns"><code>get_basis_fns</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Mesh.jl#L438-L443">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.get_∂∂Nαβ" href="#MembraneAleFem.get_∂∂Nαβ"><code>MembraneAleFem.get_∂∂Nαβ</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_∂∂Nαβ(el_id::Int64, gp_id::Int64, mesh::Mesh)::SMatrix{NEN,VOIGT,Float64}</code></pre><p>Return local basis function derivatives <span>$[𝐍^e]_{, α β}$</span> of the call to <a href="#MembraneAleFem.get_basis_fns"><code>get_basis_fns</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Mesh.jl#L368-L373">source</a></section><section><div><pre><code class="language-julia hljs">get_∂∂Nαβ(bdry::Boundary, el_id::Int64, gp_id::Int64, mesh::Mesh)</code></pre><p>Return local basis function derivatives <span>$[𝐍^e]_{, α β}$</span> of the call to <a href="#MembraneAleFem.get_basis_fns"><code>get_basis_fns</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Mesh.jl#L455-L460">source</a></section></article><h3 id="man-bc"><a class="docs-heading-anchor" href="#man-bc">Bc.jl</a><a id="man-bc-1"></a><a class="docs-heading-anchor-permalink" href="#man-bc" title="Permalink"></a></h3><p>When constructing the <a href="#MembraneAleFem.Mesh"><code>Mesh</code></a>, <a href="#MembraneAleFem.generate_scenario"><code>generate_scenario</code></a> (in <code>Mesh.jl</code>) calls <a href="#MembraneAleFem.get_scenario_bc_info"><code>get_scenario_bc_info</code></a>—which is a helper function that then calls the appropriate <a href="#MembraneAleFem.Scenario"><code>Scenario</code></a>-specific function. Each such function returns the following:</p><ul><li><code>dofs</code> –&gt; global ordering of active <a href="#MembraneAleFem.Dof.Unknown"><code>Unknown</code></a>s</li><li><code>ndf</code>  –&gt; number of active <a href="#MembraneAleFem.Dof.Unknown"><code>Unknown</code></a>s</li><li><code>ID</code>   –&gt; matrix mapping node number to indices of unknowns at that node</li><li><code>inh_dir_bcs</code> –&gt; list of inhomogeneous Dirichlet boundary conditions</li><li><code>inh_neu_bcs</code> –&gt; list of inhomogeneous Neumann boundary conditions</li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.get_scenario_bc_info" href="#MembraneAleFem.get_scenario_bc_info"><code>MembraneAleFem.get_scenario_bc_info</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_scenario_bc_info(numnp, IX, bdry_nodes, ..., p::Params; args...)</code></pre><p>Return <a href="#MembraneAleFem.Scenario"><code>Scenario</code></a>-specific information for the provided <code>Params</code>.</p><p>Each of the functions called returns <code>(dofs, ndf, ID, inh_dir_bcs, inh_neu_bcs)</code>, in that order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Bc.jl#L6-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.get_f_cavi_bc_info" href="#MembraneAleFem.get_f_cavi_bc_info"><code>MembraneAleFem.get_f_cavi_bc_info</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_f_cavi_bc_info(numnp, bdry_nodes, crnr_nodes)</code></pre><p>Generate <a href="#MembraneAleFem.Mesh"><code>Mesh</code></a> data for the flat cavity <a href="#MembraneAleFem.Scenario"><code>Scenario</code></a> <code>F_CAVI</code>.</p><p>In this scenario, a <code>STATIC</code> mesh <a href="#MembraneAleFem.Motion"><code>Motion</code></a> is required; relevant <a href="#MembraneAleFem.Dof.Unknown"><code>Unknown</code></a>s are <code>vx</code>, <code>vy</code>, and <code>λ</code>. The following boundary conditions are prescribed:</p><ul><li><span>$v_x = 1.0$</span> along the top edge (corners excluded)</li><li><span>$v_x = 0.0$</span> along all other edges (corners included)</li><li><span>$v_y = 0.0$</span> along all edges</li><li><span>$λ = 0.0$</span> at (or near) the center of the domain</li></ul><p>Note that <span>$λ$</span> is pinned to remove the global indeterminacy of the surface tension, up to a constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Bc.jl#L43-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.get_f_coue_bc_info" href="#MembraneAleFem.get_f_coue_bc_info"><code>MembraneAleFem.get_f_coue_bc_info</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_f_coue_bc_info(numnp, bdry_nodes)</code></pre><p>Generate <a href="#MembraneAleFem.Mesh"><code>Mesh</code></a> data for the flat Couette <a href="#MembraneAleFem.Scenario"><code>Scenario</code></a> <code>F_COUE</code>.</p><p>In this scenario, a <code>STATIC</code> mesh <a href="#MembraneAleFem.Motion"><code>Motion</code></a> is required; relevant <a href="#MembraneAleFem.Dof.Unknown"><code>Unknown</code></a>s are <code>vx</code>, <code>vy</code>, and <code>λ</code>. The following boundary conditions are prescribed:</p><ul><li><span>$v_x = 0.0$</span> along the bottom edge (corners included)</li><li><span>$v_x = 3.0$</span> along the top edge (corners included)</li><li><span>$v_y = 0.0$</span> along all edges</li><li><span>$\bm{\bar{F}} = 4\bm{\nu}$</span> on the left and right edges</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Bc.jl#L109-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.get_f_pois_bc_info" href="#MembraneAleFem.get_f_pois_bc_info"><code>MembraneAleFem.get_f_pois_bc_info</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_f_pois_bc_info(numnp, bdry_nodes)</code></pre><p>Generate <a href="#MembraneAleFem.Mesh"><code>Mesh</code></a> data for the flat Hagen–Poiseuille <a href="#MembraneAleFem.Scenario"><code>Scenario</code></a> <code>F_POIS</code>.</p><p>In this scenario, a <code>STATIC</code> mesh <a href="#MembraneAleFem.Motion"><code>Motion</code></a> is required; relevant <a href="#MembraneAleFem.Dof.Unknown"><code>Unknown</code></a>s are <code>vx</code>, <code>vy</code>, and <code>λ</code>. The following boundary conditions are prescribed:</p><ul><li><span>$v_x = 0.0$</span> along the top and bottom edges (corners included)</li><li><span>$v_y = 0.0$</span> on all edges</li><li><span>$\bm{\bar{F}} = 4 \bm{\nu}$</span> on the left edge</li><li><span>$\bm{\bar{F}} = 8 \bm{\nu}$</span> on the right edge</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Bc.jl#L272-L285">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.get_f_pull_bc_info" href="#MembraneAleFem.get_f_pull_bc_info"><code>MembraneAleFem.get_f_pull_bc_info</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_f_pull_bc_info(numnp, IX, bdry_nodes, bdry_inner_nodes, p::Params; args...)</code></pre><p>Generate <a href="#MembraneAleFem.Mesh"><code>Mesh</code></a> data for the flat tube-pulling <a href="#MembraneAleFem.Scenario"><code>Scenario</code></a> <code>F_PULL</code>.</p><p>Relevant unknowns are determined via <a href="#MembraneAleFem.get_dofs"><code>get_dofs</code></a>, depending on the choice of mesh <a href="#MembraneAleFem.Motion"><code>Motion</code></a>. The following boundary conditions are prescribed for all mesh motions:</p><ul><li><span>$v_z = 0$</span> on all boundaries, and all inner boundaries</li><li><span>$\bm{\bar{F}} = (k_{\text{b}} / 4)\bm{\nu}$</span> on all boundaries</li><li><span>$v_x = 0$</span>, <span>$v_y = 0$</span> at center of each edge</li><li><span>$v_x = 0$</span>, <span>$v_y = 0$</span>, <span>$v_z = \,$</span><code>args[:pull_speed]</code><span>$\bm{e}_z$</span> on nodes of the central element</li></ul><p>The following are prescribed when the <a href="#MembraneAleFem.Motion"><code>Motion</code></a> is not Lagrangian:</p><ul><li><span>$v^{\text{m}}_x = 0$</span>, <span>$v^{\text{m}}_y = 0$</span> at center of each edge</li><li><span>$v^{\text{m}}_x = 0$</span>, <span>$v^{\text{m}}_y = 0$</span>, <span>$v^{\text{m}}_z = \,$</span><code>args[:pull_speed}</code><span>$\bm{e}_z$</span> on nodes of the central element</li></ul><p>The following are prescribed when the <a href="#MembraneAleFem.Motion"><code>Motion</code></a> is either ALE-viscous or ALE-viscous-bending:</p><ul><li><span>$\bm{v}^{\text{m}} = \bm{0}$</span> on all boundaries</li></ul><p>The following are prescribed when the <a href="#MembraneAleFem.Motion"><code>Motion</code></a> is ALE-viscous-bending:</p><ul><li><span>$v^{\text{m}}_z = 0$</span> on all inner boundaries</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Bc.jl#L160-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.get_f_bend_bc_info" href="#MembraneAleFem.get_f_bend_bc_info"><code>MembraneAleFem.get_f_bend_bc_info</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_f_bend_bc_info(numnp, bdry_nodes, p::Params; args...)</code></pre><p>Generate <a href="#MembraneAleFem.Mesh"><code>Mesh</code></a> data for the flat bending <a href="#MembraneAleFem.Scenario"><code>Scenario</code></a> <code>F_BEND</code>.</p><p>Relevant unknowns are determined via <a href="#MembraneAleFem.get_dofs"><code>get_dofs</code></a>, depending on the choice of mesh <a href="#MembraneAleFem.Motion"><code>Motion</code></a>. The following boundary conditions are prescribed for all mesh motions:</p><ul><li><code>LEFT</code> edge:<ul><li><span>$\bm{v} = \bm{0}$</span></li><li><span>$M = \,$</span><code>args[:bend_mf]</code> (see <code>Params.jl</code>)</li><li>if ALE mesh motion: <span>$\bm{v}^{\text{m}} = \bm{0}$</span></li></ul></li><li><code>RIGHT</code> edge:<ul><li><span>$f_x = 0$</span> and <span>$f_y = 0$</span></li><li><span>$v_z = 0$</span></li><li><span>$M = \,$</span><code>args[:bend_mf]</code> (see <code>Params.jl</code>)</li><li>if ALE mesh motion: <span>$v^{\text{m}}_z = 0$</span></li></ul></li><li><code>BOTTOM</code> edge:<ul><li><span>$f_x = 0$</span> and <span>$f_z = 0$</span></li><li><span>$v_y = 0$</span></li><li><span>$M = 0$</span></li><li>if ALE mesh motion: <span>$v^{\text{m}}_y = 0$</span></li></ul></li><li><code>TOP</code> edge:<ul><li><span>$f_x = 0$</span> and <span>$f_z = 0$</span></li><li><span>$v_y = 0$</span></li><li><span>$M = 0$</span></li><li>if ALE mesh motion: <span>$v^{\text{m}}_y = 0$</span></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Bc.jl#L319-L346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.get_dofs" href="#MembraneAleFem.get_dofs"><code>MembraneAleFem.get_dofs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_dofs(motion::Motion)::Dict{Dof.Unknown, Int64}</code></pre><p>Return global ordering of <a href="#MembraneAleFem.Dof.Unknown"><code>Unknown</code></a> degrees of freedom, depending on the mesh <a href="#MembraneAleFem.Motion"><code>Motion</code></a>.</p><p>The following is the mapping from motion to unknowns:</p><ul><li>Lagrangian –&gt; <span>$v_x$</span>, <span>$v_y$</span>, <span>$v_z$</span>, <span>$λ$</span></li><li>Eulerian –&gt; <span>$v_x$</span>, <span>$v_y$</span>, <span>$v_z$</span>, <span>$v^{\text{m}}_x$</span>, <span>$v^{\text{m}}_y$</span>, <span>$v^{\text{m}}_z$</span>, <span>$λ$</span></li><li>ALE –&gt; <span>$v_x$</span>, <span>$v_y$</span>, <span>$v_z$</span>, <span>$v^{\text{m}}_x$</span>, <span>$v^{\text{m}}_y$</span>, <span>$v^{\text{m}}_z$</span>, <span>$λ$</span>, <span>$p^{\text{m}}$</span></li></ul><p>Note that the flat, 2-D <a href="#MembraneAleFem.Scenario"><code>Scenario</code></a>s (<code>F_CAVI</code>, <code>F_COUE</code>, <code>F_POIS</code>) have a reduced number of degrees of freedom, because there are no unknowns in the <span>$z$</span>-direction. Thus, this function is not called in those scenarios.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/input/Bc.jl#L396-L413">source</a></section></article><h2 id="man-input-jl"><a class="docs-heading-anchor" href="#man-input-jl">Input.jl</a><a id="man-input-jl-1"></a><a class="docs-heading-anchor-permalink" href="#man-input-jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MembraneAleFem.prepare_input" href="#MembraneAleFem.prepare_input"><code>MembraneAleFem.prepare_input</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepare_input(p::Params; args...)</code></pre><p>Generate and return the <a href="#MembraneAleFem.Mesh"><code>mesh</code></a>, surface position <code>xms</code>, and <a href="#MembraneAleFem.Dof.Unknown"><code>Unknown</code></a> control points <code>cps</code>.</p><p>The mesh is generated by instantiating a <a href="#MembraneAleFem.Mesh"><code>Mesh</code></a> with the provided parameters and arguments, which include the <a href="#MembraneAleFem.Scenario"><code>Scenario</code></a> and number of elements. The surface positions and initial unknowns are set with calls to <a href="#MembraneAleFem.get_1d_bspline_cps"><code>get_1d_bspline_cps</code></a> and <a href="#MembraneAleFem.get_2d_bspline_cps"><code>get_2d_bspline_cps</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sahu-lab/MembraneAleFem.jl/blob/0dcd49f9a6579539cabda55e1ac5b824dbea8ac2/src/Input.jl#L10-L21">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../overview/">« Overview</a><a class="docs-footer-nextpage" href="../analysis/">Analysis »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/sahu-lab/MembraneAleFem.jl">MembraneAleFem.jl</a> v0.1.0 docs powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 24 January 2025 22:02">Friday 24 January 2025</span>. Using Julia version 1.10.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
