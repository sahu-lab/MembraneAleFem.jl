var documenterSearchIndex = {"docs":
[{"location":"man/input/#man-input","page":"Input","title":"Input","text":"","category":"section"},{"location":"man/input/","page":"Input","title":"Input","text":"The file src/Input.jl and files contained in src/input/ are collectively referred to as the input module. Here, all calculations prior to the finite element analysis are carried out—including","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"specification of the problem scenario, choice of mesh motion, and other parameters\ngeneration of the finite element mesh\ncalculation of the basis functions and their derivatives\ninitialization of the surface position and degrees of freedom\napplication of boundary conditions","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"All files below are in the src/input/ directory.","category":"page"},{"location":"man/input/#man-enums","page":"Input","title":"Enums.jl","text":"","category":"section"},{"location":"man/input/","page":"Input","title":"Input","text":"The following enums are defined to simplify problem input.","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"Scenario","category":"page"},{"location":"man/input/#MembraneAleFem.Scenario","page":"Input","title":"MembraneAleFem.Scenario","text":"Scenario\n\nScenarios to simulate: instances(Scenario)\n\nF_CAVI = 1 –> lid-driven cavity\nF_COUE = 2 –> Couette flow\nF_POIS = 3 –> Hagen–Poiseuille flow\nF_PULL = 4 –> tether pulling from a flat patch\nF_BEND = 5 –> bending of a flat patch\n\nThe first letter indicates mesh Topology: F for a flat patch and C for a cylinder. At present, no cylindrical scenarios are implemented.\n\nTo create a new scenario:\n\nadd and export a new entry in the Scenario enum\nedit get_scenario_bc_info in src/input/Bc.jl\nwrite the corresponding apply_<SCENARIO>_bcs function in src/input/Mesh.jl \nadd the new scenario to the implemented list in src/input/Params.jl\n\n\n\n\n\n","category":"type"},{"location":"man/input/","page":"Input","title":"Input","text":"Topology","category":"page"},{"location":"man/input/#MembraneAleFem.Topology","page":"Input","title":"MembraneAleFem.Topology","text":"Topology\n\nMesh topologies: instances(Topology)\n\nFLAT     = 1\nCYLINDER = 2\n\n\n\n\n\n","category":"type"},{"location":"man/input/","page":"Input","title":"Input","text":"Motion","category":"page"},{"location":"man/input/#MembraneAleFem.Motion","page":"Input","title":"MembraneAleFem.Motion","text":"Motion\n\nTypes of mesh motion: instances(Motion)\n\nSTATIC = 1 –> mesh does not move\nEUL    = 2 –> Eulerian mesh motion\nLAG    = 3 –> Lagrangian mesh motion\nALEV   = 4 –> ALE-viscous mesh motion\nALEVB  = 5 –> ALE-viscous-bending mesh motion\n\nThe choice of motion is stored in Params.motion variable in Params.jl, and is relevant both to the specification of boundary conditions in Bc.jl and the finite element analysis.\n\n\n\n\n\n","category":"type"},{"location":"man/input/","page":"Input","title":"Input","text":"Boundary","category":"page"},{"location":"man/input/#MembraneAleFem.Boundary","page":"Input","title":"MembraneAleFem.Boundary","text":"Boundary\n\nEnumerate four mesh boundaries: instances(Boundary), never to be used as an index.\n\nBOTTOM = 1\nRIGHT  = 2\nTOP    = 3\nLEFT   = 4\n\n\n\n\n\n","category":"type"},{"location":"man/input/","page":"Input","title":"Input","text":"Corner","category":"page"},{"location":"man/input/#MembraneAleFem.Corner","page":"Input","title":"MembraneAleFem.Corner","text":"Corner\n\nEnumerate four mesh corners: instances(Corner), never to be used as an index.\n\nBOTTOM_LEFT  = 1\nBOTTOM_RIGHT = 2\nTOP_LEFT     = 3\nTOP_RIGHT    = 4\n\n\n\n\n\n","category":"type"},{"location":"man/input/","page":"Input","title":"Input","text":"Neumann","category":"page"},{"location":"man/input/#MembraneAleFem.Neumann","page":"Input","title":"MembraneAleFem.Neumann","text":"Neumann\n\nEnumerate types of Neumann boundary conditions: instances(Neumann)\n\nSHEAR     = 1 –> apply in-plane force/length in the τ direction\nSTRETCH   = 2 –> apply in-plane force/length in the ν direction\nMOMENT    = 3 –> apply boundary moment\n\nAssociate finite element calculations are found in calc_bdry_element_residual\n\n\n\n\n\n","category":"type"},{"location":"man/input/","page":"Input","title":"Input","text":"Curve","category":"page"},{"location":"man/input/#MembraneAleFem.Curve","page":"Input","title":"MembraneAleFem.Curve","text":"Curve\n\nEnumerate types of curves: instances(Curve)\n\nCLAMPED\nCLOSED\n\nThese curves are used to generate B-spline basis functions—see Spline.jl\n\n\n\n\n\n","category":"type"},{"location":"man/input/#man-params","page":"Input","title":"Params.jl","text":"","category":"section"},{"location":"man/input/","page":"Input","title":"Input","text":"The requisite parameters for each simulation are split between the Params struct and the keyword arguments args. The data contained in Params is meant to be immutable, even across restarted (or continued) simulations. For this reason, temporal data (the initial time t0, initial time ID t0_id, and time steps Δts) is treated as a keyword argument, despite it being required for every simulation. Additional details about required keywords are contained in check_params.","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.Params","category":"page"},{"location":"man/input/#MembraneAleFem.Params","page":"Input","title":"MembraneAleFem.Params","text":"Params\n\nParameters that must be specified for any simulation.\n\nFor Scenario-specific data that must be included via keyword arguments, see check_params. The following information is contained:\n\nmotion::Motion     → type of motion\nscenario::Scenario → type of scenario\nnum1el::Int64   → number of elements in ζ^1\nnum2el::Int64   → number of elements in ζ^2\noutput::Bool    → write output (yes by default)\nlength::Float64 → length, in real space\nkb::Float64     → mean bending modulus\nkg::Float64     → Gaussian bending modulus\nζv::Float64     → membrane viscosity\npn::Float64     → normal pressure (body force)\npoly::Int64     → polynomial order of basis functions\ngp1d::Int64     → number of Gauss points, in 1-D\nnders::Int64    → number of 1-D B-spline derivatives\nnen::Int64      → number of element nodes\nαdb::Float64    → Dohrmann–Bochev parameter\nαm::Float64     → mesh parameter\nεk::Float64     → tolerance numerical calculation of matrix K\nεnr::Float64    → Netwon–Raphson tolerance\n\n\n\n\n\n","category":"type"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.check_params","category":"page"},{"location":"man/input/#MembraneAleFem.check_params","page":"Input","title":"MembraneAleFem.check_params","text":"check_params(p::Params; args...)\n\nCheck relevant parameters, including scenario-specific keyword arguments.\n\nFor any simulation, the fields t0, t0_id, and Δts are required. If data is output (as is the default, for p.output), the output path out_path and file name out_file are necessary. Finally, the information needed to solve the various Scenarios is checked.\n\n\n\n\n\n","category":"function"},{"location":"man/input/#man-module-dof","page":"Input","title":"Dof.jl","text":"","category":"section"},{"location":"man/input/","page":"Input","title":"Input","text":"Within our ALE formalism, the membrane position boldsymbolx is not a fundamental unknown. The mesh velocity boldsymbolv^textm, on the other hand, is a fundamental unknown, and over a time step Delta t the membrane position is updated according to","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"boldsymbolx (zeta^alpha t + Delta t)\n =  boldsymbolx (zeta^alpha t)\n +  Delta t  boldsymbolv^textm (zeta^alpha t + Delta t)\n","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"where Delta t is one of the entries of the array ΔTS specified in Params.jl. The membrane position is thus treated differently from the fundamental unknowns. For this reason, we define all possible fundamental unknowns and the three Cartesian components of the position in the Dof module:","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"Dof.Unknown","category":"page"},{"location":"man/input/#MembraneAleFem.Dof.Unknown","page":"Input","title":"MembraneAleFem.Dof.Unknown","text":"Dof.Unknown\n\nPossible degrees of freedom (or fundamental unknowns) at each node.\n\nFor different mesh motions, different fundamental unknowns are required. A Lagrangian simulation requires only vx, vy, vz, and λ, while an ALE simulation requires all eight fundamental unknowns. Currently, the mapping from the choice of Motion to the corresponding fundamental unknowns is specified in the function get_dofs and stored in Mesh.dofs.\n\nThis enum is encapsulated in a module; access elements with e.g. Dof.vx.\n\nTypes of fundamental unknowns:\n\nvx  –> x-velocity,      v_x\nvy  –> y-velocity,      v_y\nvz  –> z-velocity,      v_z\nvmx –> x-mesh velocity, v^textm_x\nvmy –> y-mesh velocity, v^textm_y\nvmz –> z-mesh velocity, v^textm_z\nλ   –> surface tension,     λ\npm  –> mesh pressure,       p^textm\n\n\n\n\n\n","category":"type"},{"location":"man/input/","page":"Input","title":"Input","text":"Dof.Position","category":"page"},{"location":"man/input/#MembraneAleFem.Dof.Position","page":"Input","title":"MembraneAleFem.Dof.Position","text":"Dof.Position\n\nCartesian components of the mesh position at each node.\n\nThis enum is encapsulated in a module; access elements with e.g. Dof.xm.\n\nOptions:\n\nxm –> x-position\nym –> y-position\nzm –> z-position\n\n\n\n\n\n","category":"type"},{"location":"man/input/#man-spline","page":"Input","title":"Spline.jl","text":"","category":"section"},{"location":"man/input/","page":"Input","title":"Input","text":"All B-spline calculations independent from finite element analysis, based entirely on The NURBS Book (Piegl and Tiller, 1997). See in particular Chapter Two for a description of B-spline functions, and Chapter Three for an explanation of how the basis functions are used to generate 1D curves and 2D surfaces in mathbbR^3. We employ the same terminology in our code.","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"KnotVector","category":"page"},{"location":"man/input/#MembraneAleFem.KnotVector","page":"Input","title":"MembraneAleFem.KnotVector","text":"KnotVector(ζs::Vector{Float64}, nel::Int64, poly::Int64, curve::Curve)\n\nVector of knots, with which all 1-D B-spline functions are calculated.\n\nThe knot vector struct contains four fields:\n\nζs –> list of all knots, including repeated ones\nnel –> number of 1-D elements, or knot spans\npoly –> polynomial order\ncurve –> type of Curve, which is either CLAMPED or CLOSED\n\nAll of these data are not required to generate a knot vector. Two constructors are available—see knot_vector\n\n\n\n\n\n","category":"type"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.knot_vector","category":"page"},{"location":"man/input/#MembraneAleFem.knot_vector","page":"Input","title":"MembraneAleFem.knot_vector","text":"knot_vector(ζs::Vector{Float64}, poly::Int64, curve::Curve)\n\nExternal constructor of the KnotVector struct, where knots need not be uniform.\n\nThe list of knots ζs, polynomial order poly, and Curve type curve are passed in. If they represent a valid knot vector, then the struct is created.\n\n\n\n\n\nknot_vector(nel::Int64, poly::Int64, curve::Curve)\n\nExternal constructor of the KnotVector struct with uniform knots.\n\nThe number of elements nel, polynomial order poly, and Curve type curve are passed in. If the curve is CLOSED, then no knots are repeated. If the curve is CLAMPED, then the first and last (poly+1) knots are repeated. In both cases, the generated list of knots ζs ranges from 0 to 1.\n\n\n\n\n\n","category":"function"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.get_knot_span_index","category":"page"},{"location":"man/input/#MembraneAleFem.get_knot_span_index","page":"Input","title":"MembraneAleFem.get_knot_span_index","text":"get_knot_span_index(kv::KnotVector, ζ::Float64)::Int64\n\nReturn knot span index of ζ in CLAMPED or CLOSED KnotVector kv.\n\nAlgorithm A2.1 in Chap. 2, §5 of Piegl and Tiller (1997) ensures kv.ζs[idx] ≤ ζ < kv.ζs[idx+1], where idx is the returned value. The algorithm, valid only for CLAMPED knots, is here extended to CLOSED knots as well.\n\n\n\n\n\n","category":"function"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.get_bspline_vals","category":"page"},{"location":"man/input/#MembraneAleFem.get_bspline_vals","page":"Input","title":"MembraneAleFem.get_bspline_vals","text":"get_bspline_vals(kv::KnotVector, ζ::Float64)::Vector{Float64}\n\nReturn kv.poly+1 nonzero B-spline functions at ζ for the given KnotVector kv.\n\nAlgorithm A2.2 in Chap. 2, §5 of Piegl and Tiller (1997), valid for CLAMPED knot vectors with (kv.poly+1) repeated knots at the start and end, is also used for CLOSED knot vectors. The local-to-global mapping returned by get_bspline_indices is necessary to determine which global basis functions are nonzero at the provided ζ.\n\n\n\n\n\n","category":"function"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.get_bspline_ders","category":"page"},{"location":"man/input/#MembraneAleFem.get_bspline_ders","page":"Input","title":"MembraneAleFem.get_bspline_ders","text":"get_bspline_ders(kv::KnotVector, ζ::Float64, num_ders::Int64)::Matrix{Float64}\n\nReturn B-spline functions and num_ders derivatives at ζ for the given KnotVector kv.\n\nAlgorithm A2.3 in Chap. 2, §5 of Piegl and Tiller (1997), valid for CLAMPED knot vectors with (kv.poly+1) repeated knots at the start and end, is also used for CLOSED knot vectors. Here num_ders is required to not be greater than kv.poly, and also greater than or equal to zero. The local-to-global mapping returned by get_bspline_indices is necessary to determine which global basis functions are nonzero at the provided ζ.\n\nThe returned matrix has kv.poly+1 rows and num_ders+1 columns. The first column contains the functions themselves, and is thus identical to the output of get_bspline_vals. The second column contains the first derivatives, and so on.\n\n\n\n\n\n","category":"function"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.get_bspline_indices","category":"page"},{"location":"man/input/#MembraneAleFem.get_bspline_indices","page":"Input","title":"MembraneAleFem.get_bspline_indices","text":"get_bspline_indices(kv::KnotVector, ζ::Float64)::Vector{Int64}\n\nReturn global indices of nonzero B-splines at the value ζ in the KnotVector kv.\n\nBy definition, there are only kv.poly+1 nonzero B-spline functions at any ζ. The functions get_bspline_vals and get_bspline_ders calculate these nonzero quantities, and the mapping returned here places them within the global ordering. The global indices are the same for all ζ within a single knot span, and thus we begin by calling get_knot_span_index.\n\nBoth CLAMPED knot vectors, with (kv.poly+1) repeats at the start and end, as well as CLOSED knot vectors, are handled.\n\n\n\n\n\nget_bspline_indices(kv::KnotVector, ks_id::Int64)::Vector{Int64}\n\nReturn global indices of nonzero B-splines at ks_id^textrmth knot span in the KnotVector kv.\n\nBy definition, there are only kv.poly+1 nonzero B-spline functions over any knot span. The mapping returned here places these functions within the global ordering. Both CLAMPED knot vectors, with (kv.poly+1) repeats at the start and end, as well as CLOSED knot vectors, are handled. Note that ks_id is not the element ID eid; rather, ks_id = eid + kv.poly\n\n\n\n\n\n","category":"function"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.get_1d_bspline_cps","category":"page"},{"location":"man/input/#MembraneAleFem.get_1d_bspline_cps","page":"Input","title":"MembraneAleFem.get_1d_bspline_cps","text":"get_1d_bspline_cps(kv::KnotVector, x::Function)::Vector{Float64}\n\nReturn the global control points  x^_K  for the function x(ζ).\n\nThe global control points  x^_K  are calculated for the provided KnotVector kv such that\n\nx(ζ)\n approx  sum_K = 1^textttnn N^_K (ζ)  x^_K\n\n\nwhere x(ζ) is the provided x::Function and here textttnn is the number of global 1-D nodes. To determine the unknown  x^_K , a set of textttnn collocation points  ζ^_J  is chosen via collocate_ζ. A matrix equation is then obtained as\n\nx (ζ^_J)\n =  N^_K (ζ^_J)  x^_K\n\n\nwhere the N^_K (ζ^_J) are determined with get_bspline_indices and get_bspline_vals. The x^_K are then calculated and returned as a vector.\n\n\n\n\n\n","category":"function"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.get_2d_bspline_cps","category":"page"},{"location":"man/input/#MembraneAleFem.get_2d_bspline_cps","page":"Input","title":"MembraneAleFem.get_2d_bspline_cps","text":"get_2d_bspline_cps(kv1::KnotVector, kv2::KnotVector, x::Function)::Matrix{Float64}\n\nReturn the global control points  x^_K  for the scalar-valued function z(ζ^1 ζ^2).\n\nThe procedure of get_1d_bspline_cps is repeated, except in this case collocation points are chosen across the 2-D parametric domain (ζ^1 ζ^2).\n\n\n\n\n\n","category":"function"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.collocate_ζ","category":"page"},{"location":"man/input/#MembraneAleFem.collocate_ζ","page":"Input","title":"MembraneAleFem.collocate_ζ","text":"collocate_ζ(kv::KnotVector)::Vector{Float64}\n\nTake a KnotVector kv and return a list of points ζ used for collocation.\n\nThe length of the returned list of ζ values is equal to the number of global basis functions associated with the provided knot vector. Both CLAMPED and CLOSED knot vectors are accounted for.\n\n\n\n\n\n","category":"function"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.get_unique_1d_elements","category":"page"},{"location":"man/input/#MembraneAleFem.get_unique_1d_elements","page":"Input","title":"MembraneAleFem.get_unique_1d_elements","text":"get_unique_1d_elements(kv::KnotVector)\n\nGet all unique elements for a given knot vector kv.\n\nThis function returns several quantities, in the following order:\n\nuel_num::Int64 -> number of unique elements\nnum_el::Int64 -> number of elements\nuel_ids::Vector{Int64} -> mapping from element id to unique element id\nuel_list::Vector{Tuple{Float64, Float64}} -> start and end ζ for each unique element\n\n\n\n\n\n","category":"function"},{"location":"man/input/#man-gauss-point","page":"Input","title":"GaussPoint.jl","text":"","category":"section"},{"location":"man/input/","page":"Input","title":"Input","text":"As is standard in finite element analysis, Gauss–Legendre quadrature is used to approximate integrals over the parametric domain. Here, the primary objective is to calculate the 1-D integral","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"I_1\n =  int_ζ_textttlo^ζ_texttthi  f(ζ)  textd ζ\n","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"The domain of integration is mapped from  ζ_textttlo ζ_texttthi  to -1 +1 via the change of variables","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"ζ\n =  dfrac12  ξ  big(\n\tζ_texttthi\n\t- ζ_textttlo\nbig)\n +  dfrac12  big(\n\tζ_texttthi\n\t+ ζ_textttlo\nbig)\n","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"for which the integral I_1 is equivalently given by","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"I_1\n =  dfrac12  big(\n\tζ_texttthi\n\t- ζ_textttlo\nbig) int_-1^+1  f bigg(\n\tdfrac12 Big\n\t\tξ big(\n\t\t\tζ_texttthi\n\t\t\t- ζ_textttlo\n\t\tbig)\n\t\t+ big(\n\t\t\tζ_texttthi\n\t\t\t+ ζ_textttlo\n\t\tbig)\n\tBig\nbigg)  textd ξ\n =  dfrac12  big(\n\tζ_texttthi\n\t- ζ_textttlo\nbig) int_-1^+1  hatf (ξ)  textd ξ\n","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"At this point, the integral is approximated by applying the Gaussian quadrature formula","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"I_1\n   dfrac12  big(\n\tζ_texttthi\n\t- ζ_textttlo\nbig)  sum_k = 1^textttngp hatw_k  hatf (ξ_k)\n","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"where textttngp is the number of 1D Gauss points, hatw_k are the corresponding weights, and ξ_k are the associated Gauss–Legendre points. In our code, GaussPointsξ contains textttngp, hatw_k, and ξ_k. Note that this struct is the same for every line element, because  ξ  -1 +1 always.","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"GaussPointsξ","category":"page"},{"location":"man/input/#MembraneAleFem.GaussPointsξ","page":"Input","title":"MembraneAleFem.GaussPointsξ","text":"GaussPointsξ(ngp::Int64)\n\nWeights hatw_k and points ξ_k on the interval -1 +1 with which a 1-D integral is approximated.\n\nThe struct has three fields:\n\nngp –> number of Gaussian quadrature points\nξs  –> set of points ξ_k\nws  –> set of weights hatw_k\n\nCalculations from Wikipedia: Gaussian quadrature.\n\n\n\n\n\n","category":"type"},{"location":"man/input/","page":"Input","title":"Input","text":"In our finite element implementation, it is often convenient to evaluate integrals over the original variable ζ rather than the transformed variable ξ. To this end, we recognize that","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"I_1\n   sum_k = 1^textttngp w_k  f (ζ_k)\n","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"where","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"w_k\n = dfrac12  hatw_k  big(\n\tζ_texttthi\n\t- ζ_textttlo\nbig)\nqquad\ntextand\nqquad\nζ_k\n =  dfrac12 Big\n\tξ_k big(\n\t\tζ_texttthi\n\t\t- ζ_textttlo\n\tbig)\n\t+ big(\n\t\tζ_texttthi\n\t\t+ ζ_textttlo\n\tbig)\nBig\n","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"In our code, GaussPointsζ contains ngp, w_k, and ζ_k.","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"GaussPointsζ","category":"page"},{"location":"man/input/#MembraneAleFem.GaussPointsζ","page":"Input","title":"MembraneAleFem.GaussPointsζ","text":"GaussPointsζ(gpsξ::GaussPointsξ, ζlo::Float64, ζhi::Float64)\n\nWeights w_k and points ζ_k with which a 1-D integral is approximated over ζlo ≤ ζ ≤ ζhi.\n\nCalculated via the transform from ξ to ζ via the relations\n\nζ_k = ξ_k (ζhi - ζlo) / 2 + (ζhi + ζlo) / 2\n\nw_k = hatw_k (ζhi - ζlo) / 2\n\nThe struct has three fields:\n\nngp –> number of Gaussian quadrature points\nζs  –> set of points ζ_k\nws  –> set of weights w_k\n\n\n\n\n\n","category":"type"},{"location":"man/input/#man-gp-basis-fn","page":"Input","title":"GpBasisFn.jl","text":"","category":"section"},{"location":"man/input/","page":"Input","title":"Input","text":"Calculation of nonzero B-spline basis functions at every Gaussian quadrature point. Since the basis functions are determined upon discretizing the parametric domain, they are calculated once and then stored in the structs listed below—which systematically build up in complexity.","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"GpBasisFnsζ","category":"page"},{"location":"man/input/#MembraneAleFem.GpBasisFnsζ","page":"Input","title":"MembraneAleFem.GpBasisFnsζ","text":"GpBasisFnsζ(gpwζ::Float64, ζ::Float64, kv::KnotVector)\n\n1-D basis functions N(ζ) at the provided quadrature point ζ with weight gpwζ.\n\nThe B-spline values and derivatives are determined with get_bspline_ders and stored here. The struct contains four fields:\n\nw   –> Gauss point weight, passed in as gpw\nN   –> (poly+1)×1 vector of nonzero basis functions N(ζ)\ndN  –> (poly+1)×1 vector of nonzero first derivatives N(ζ)\nddN –> (poly+1)×1 vector of nonzero second derivatives N(ζ)\n\n\n\n\n\n","category":"type"},{"location":"man/input/","page":"Input","title":"Input","text":"GpBasisFnsζα","category":"page"},{"location":"man/input/#MembraneAleFem.GpBasisFnsζα","page":"Input","title":"MembraneAleFem.GpBasisFnsζα","text":"GpBasisFnsζα(fns1::GpBasisFnsζ, fns2::GpBasisFnsζ)\n\n2-D basis functions N(ζ^α) at a single Gauss point ζ^α, as set by 1-D GpBasisFnsζ fns1 and fns2.\n\nHere ζ^1 and ζ^2 respectively correspond to the ζ values passed to fns1 and fns2, even though this information is not stored. The 2-D basis functions are calculated as the tensor product of 1-D functions. The struct contains four fields:\n\nw –> Gauss point weight, given by fns1.w × fns2.w\nN –> NEN×1 vector of nonzero basis functions N(ζ^α), ordered by the tensor product structure\n∂Nα –> NEN×2 matrix of first derivatives: rows respectively contain N_ 1 and N_ 2\n∂∂Nαβ –> NEN×3 matrix of second derivatives: rows respectively contain N_ 1 1, N_ 2 2, and N_ 1 2\n\n\n\n\n\n","category":"type"},{"location":"man/input/","page":"Input","title":"Input","text":"LineGpBasisFns","category":"page"},{"location":"man/input/#MembraneAleFem.LineGpBasisFns","page":"Input","title":"MembraneAleFem.LineGpBasisFns","text":"LineGpBasisFns(kv::KnotVector, ngp::Int64)\n\n1-D B-spline basis functions and derivatives at all quadrature points on the domain of the KnotVector kv.\n\nBasis functions are determined at each of the ngp Gauss points, over each element. When using B-splines, scenarios often arise where the basis functions are identical across many elements. We accordingly store only the 1-D basis functions over unique elements, as well as a mapping from elements to unique elements. The basis functions at the edges of the 1-D parametric domain are stored separately, as they are required subsequently for application of boundary conditions. The struct has five fields:\n\nnel –> number of elements in the KnotVector kv\nuel_ids –> mapping from elem_id to unique_elem_id\nufns –> num_unique_elems×ngp matrix of unique 1-D basis functions, of type GpBasisFnsζ\nζmin_fns –> 1-D basis functions at the min value of the parametric domain\nζmax_fns –> 1-D basis functions at the max value of the parametric domain\n\nNote that this struct contains no information about how basis functions vary in the orthogonal parametric direction, and thus cannot be directly used to apply boundary conditions. See BdryGpBasisFns.\n\n\n\n\n\n","category":"type"},{"location":"man/input/","page":"Input","title":"Input","text":"BdryGpBasisFns","category":"page"},{"location":"man/input/#MembraneAleFem.BdryGpBasisFns","page":"Input","title":"MembraneAleFem.BdryGpBasisFns","text":"BdryGpBasisFns(line_gp_fns::LineGpBasisFns, perp_edge_fns::GpBasisFnsζ, bdry::Boundary)\n\n2-D B-spline basis functions and derivatives at all quadrature points on a boundary.\n\nThe LineGpBasisFns struct line_gp_fns contains all 1-D basis functions and derivatives along the boundary, with ngp Gauss points for each element. Here perp_edge_fns are the basis functions and derivatives at the boundary in the orthogonal parametric direction, as contained in a GpBasisFnsζ struct. For example, on the RIGHT boundary, line_gp_fns captures 1-D derivatives in the ζ^2 direction, while perp_edge_fns contains 1-D derivatives in the ζ^1 direction on the right edge. With knowledge of the underlying tensor product structure (Piegl and Tiller, 1997), the 2-D basis functions along the specified Boundary bdry are generated. The struct has four fields:\n\nnel –> number of elements associated with LineGpBasisFns line_gp_fns\nuel_ids –> mapping from elem_id to unique_elem_id\nufns –> num_unique_elems×ngp matrix of unique 2-D basis functions, of type GpBasisFnsζα\nbdry –> Boundary of the parametric domain\n\n\n\n\n\n","category":"type"},{"location":"man/input/","page":"Input","title":"Input","text":"AreaGpBasisFns","category":"page"},{"location":"man/input/#MembraneAleFem.AreaGpBasisFns","page":"Input","title":"MembraneAleFem.AreaGpBasisFns","text":"AreaGpBasisFns(line_gp_fns1::LineGpBasisFns, line_gp_fns2::LineGpBasisFns)\n\n2-D B-spline basis functions and derivatives at all quadrature points in the mesh area.\n\nThe two LineGpBasisFns structs passed in, line_gp_fns1 and line_gp_fns2, respectively contain 1-D derivatives in the ζ^1 and ζ^2 directions. With the tensor product structure of B-splines over a surface (Piegl and Tiller, 1997), it is straightforward to calculate the 2-D basis functions and their derivatives. As is the case for LineGpBasisFns, a mapping from elements to unique elements is generated; only unique basis function calculations are stored. This struct has three fields:\n\nnel –> number of area elements\nuel_ids –> mapping from elem_id to unique_elem_id\nufns –> num_unique_elems×ngp matrix of unique 2-D basis functions, of type GpBasisFnsζα\n\n\n\n\n\n","category":"type"},{"location":"man/input/#man-mesh","page":"Input","title":"Mesh.jl and Bc.jl","text":"","category":"section"},{"location":"man/input/","page":"Input","title":"Input","text":"The mesh is one of the main constructions required for finite element analysis. In this codebase, the functions associated with mesh generation are divided into two files. Mesh.jl deals with aspects of mesh generation that are independent of the scenario under consideration, while Bc.jl handles the boundary conditions and their effect on mesh organization—which is scenario-dependent.","category":"page"},{"location":"man/input/#Mesh.jl","page":"Input","title":"Mesh.jl","text":"","category":"section"},{"location":"man/input/","page":"Input","title":"Input","text":"All relevant information is contained in the Mesh struct, and will not change over the course of a simulation.","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"Mesh","category":"page"},{"location":"man/input/#MembraneAleFem.Mesh","page":"Input","title":"MembraneAleFem.Mesh","text":"Mesh(p::Params; args...)\n\nThe generated mesh, which includes the degree-of-freedom numbering and all basis functions for the given Scenario.\n\nThis struct contains the following scenario-independent fields:\n\nnum1el –> number of elements in ζ^1 direction\nnum2el –> number of elements in ζ^2 direction\nnumel –> number of area elements\nnum1np –> number of nodal points in ζ^1 direction\nnum2np –> number of nodal points in ζ^2 direction\nnumnp –>  number of nodal points on the 2-d mesh\nIX –> matrix containing nonzero node numbers for each area element\nbdry_elems –> mapping from Boundary to element numbers\ncrnr_elems –> mapping from Corner to element number\nbdry_nodes –> mapping from Boundary to node numbers\nbdry_inner_nodes –> mapping from Boundary to inner node numbers\ncrnr_nodes –> mapping from Corner to node number\ncrnr_inner_nodes –> mapping from Corner to inner node number\nkv1 –> KnotVector along ζ^1 direction\nkv2 –> KnotVector along ζ^2 direction\narea_gp_fns –> AreaGpBasisFns: 2-D area basis functions\nbdry_gp_fns –> mapping from Boundary to BdryGpBasisFns\ncrnr_gp_fns –> mapping from Corner to 2-D basis functions GpBasisFnsζα\n\nThe generated mesh depends on the problem being solved. The function generate_scenario uses the scenario-specific results from Bc.jl to set the following scenario-dependent fields:\n\ntopology –> surface Topology\ndofs –> list of active Unknowns with global ordering\nndf –> number of active Unknowns\nID –> matrix mapping node number to indices of unknowns at that node\nID_inv –> inverse of ID: map unknown_id to (node_number, dof_number)\nnmdf –> total number of mesh degrees of freedom\nLM –> map from area element to indices of all unknowns of that element\ninh_dir_bcs –> list of inhomogeneous Dirichlet boundary conditions\ninh_neu_bcs –> list of inhomogeneous Neumann boundary conditions\n\n\n\n\n\n","category":"type"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.generate_scenario","category":"page"},{"location":"man/input/#MembraneAleFem.generate_scenario","page":"Input","title":"MembraneAleFem.generate_scenario","text":"generate_scenario(numel, numnp, IX, bdry_nodes, ..., p::Params; args...)\n\nApply scenario-specific boundary conditions towards mesh generation.\n\nChecks to see whether a helper function is available in Bc.jl for the given Scenario, and then constructs the ID matrix that maps from nodes to global degrees of freedom. The inverse ID_inv is also generated, as is the LM matrix—which provides the local degrees of freedom for each element.\n\n\n\n\n\n","category":"function"},{"location":"man/input/","page":"Input","title":"Input","text":"The following helper functions allow the user to easily obtain basis functions, their derivatives, and Gauss point weights both in the mesh interior and on the mesh boundary.","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.get_basis_fns","category":"page"},{"location":"man/input/#MembraneAleFem.get_basis_fns","page":"Input","title":"MembraneAleFem.get_basis_fns","text":"get_basis_fns(el_id::Int64, gp_id::Int64, mesh::Mesh)::GpBasisFnsζα\n\nReturn GpBasisFnsζα of the gp_id^textth 2-D Gauss point of the el_id^textth area element.\n\n\n\n\n\nget_basis_fns(bdry::Boundary, el_id::Int64, gp_id::Int64, mesh::Mesh)::GpBasisFnsζα\n\nReturn GpBasisFnsζα of the gp_id^textth 1-D Gauss point of the el_id^textth element on the Boundary bdry.\n\n\n\n\n\n","category":"function"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.get_gpw","category":"page"},{"location":"man/input/#MembraneAleFem.get_gpw","page":"Input","title":"MembraneAleFem.get_gpw","text":"get_gpw(el_id::Int64, gp_id::Int64, mesh::Mesh)::Float64\n\nReturn the Gauss point weight of the call to get_basis_fns.\n\n\n\n\n\nget_gpw(bdry::Boundary, el_id::Int64, gp_id::Int64, mesh::Mesh)::Vector{Float64}\n\nReturn the Gauss point weight of the call to get_basis_fns.\n\n\n\n\n\n","category":"function"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.get_N","category":"page"},{"location":"man/input/#MembraneAleFem.get_N","page":"Input","title":"MembraneAleFem.get_N","text":"get_N(el_id::Int64, gp_id::Int64, mesh::Mesh)::SVector{NEN,Float64}\n\nReturn local basis functions 𝐍^e of the call to get_basis_fns.\n\n\n\n\n\nget_N(bdry::Boundary, el_id::Int64, gp_id::Int64, mesh::Mesh)\n\nReturn local basis functions 𝐍^e of the call to get_basis_fns.\n\n\n\n\n\n","category":"function"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.get_∂Nα","category":"page"},{"location":"man/input/#MembraneAleFem.get_∂Nα","page":"Input","title":"MembraneAleFem.get_∂Nα","text":"get_∂Nα(el_id::Int64, gp_id::Int64, mesh::Mesh)::SMatrix{NEN,ζDIM,Float64}\n\nReturn local basis function derivatives 𝐍^e_ α of the call to get_basis_fns.\n\n\n\n\n\nget_∂Nα(bdry::Boundary, el_id::Int64, gp_id::Int64, mesh::Mesh)\n\nReturn local basis function derivatives 𝐍^e_ α of the call to get_basis_fns.\n\n\n\n\n\n","category":"function"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.get_∂∂Nαβ","category":"page"},{"location":"man/input/#MembraneAleFem.get_∂∂Nαβ","page":"Input","title":"MembraneAleFem.get_∂∂Nαβ","text":"get_∂∂Nαβ(el_id::Int64, gp_id::Int64, mesh::Mesh)::SMatrix{NEN,VOIGT,Float64}\n\nReturn local basis function derivatives 𝐍^e_ α β of the call to get_basis_fns.\n\n\n\n\n\nget_∂∂Nαβ(bdry::Boundary, el_id::Int64, gp_id::Int64, mesh::Mesh)\n\nReturn local basis function derivatives 𝐍^e_ α β of the call to get_basis_fns.\n\n\n\n\n\n","category":"function"},{"location":"man/input/#man-bc","page":"Input","title":"Bc.jl","text":"","category":"section"},{"location":"man/input/","page":"Input","title":"Input","text":"When constructing the Mesh, generate_scenario (in Mesh.jl) calls get_scenario_bc_info—which is a helper function that then calls the appropriate Scenario-specific function. Each such function returns the following:","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"dofs –> global ordering of active Unknowns\nndf  –> number of active Unknowns\nID   –> matrix mapping node number to indices of unknowns at that node\ninh_dir_bcs –> list of inhomogeneous Dirichlet boundary conditions\ninh_neu_bcs –> list of inhomogeneous Neumann boundary conditions","category":"page"},{"location":"man/input/","page":"Input","title":"Input","text":"get_scenario_bc_info","category":"page"},{"location":"man/input/#MembraneAleFem.get_scenario_bc_info","page":"Input","title":"MembraneAleFem.get_scenario_bc_info","text":"get_scenario_bc_info(numnp, IX, bdry_nodes, ..., p::Params; args...)\n\nReturn Scenario-specific information for the provided Params.\n\nEach of the functions called returns (dofs, ndf, ID, inh_dir_bcs, inh_neu_bcs), in that order.\n\n\n\n\n\n","category":"function"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.get_f_cavi_bc_info","category":"page"},{"location":"man/input/#MembraneAleFem.get_f_cavi_bc_info","page":"Input","title":"MembraneAleFem.get_f_cavi_bc_info","text":"get_f_cavi_bc_info(numnp, bdry_nodes, crnr_nodes)\n\nGenerate Mesh data for the flat cavity Scenario F_CAVI.\n\nIn this scenario, a STATIC mesh Motion is required; relevant Unknowns are vx, vy, and λ. The following boundary conditions are prescribed:\n\nv_x = 10 along the top edge (corners excluded)\nv_x = 00 along all other edges (corners included)\nv_y = 00 along all edges\nλ = 00 at (or near) the center of the domain\n\nNote that λ is pinned to remove the global indeterminacy of the surface tension, up to a constant.\n\n\n\n\n\n","category":"function"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.get_f_coue_bc_info","category":"page"},{"location":"man/input/#MembraneAleFem.get_f_coue_bc_info","page":"Input","title":"MembraneAleFem.get_f_coue_bc_info","text":"get_f_coue_bc_info(numnp, bdry_nodes)\n\nGenerate Mesh data for the flat Couette Scenario F_COUE.\n\nIn this scenario, a STATIC mesh Motion is required; relevant Unknowns are vx, vy, and λ. The following boundary conditions are prescribed:\n\nv_x = 00 along the bottom edge (corners included)\nv_x = 30 along the top edge (corners included)\nv_y = 00 along all edges\nbmbarF = 4bmnu on the left and right edges\n\n\n\n\n\n","category":"function"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.get_f_pois_bc_info","category":"page"},{"location":"man/input/#MembraneAleFem.get_f_pois_bc_info","page":"Input","title":"MembraneAleFem.get_f_pois_bc_info","text":"get_f_pois_bc_info(numnp, bdry_nodes)\n\nGenerate Mesh data for the flat Hagen–Poiseuille Scenario F_POIS.\n\nIn this scenario, a STATIC mesh Motion is required; relevant Unknowns are vx, vy, and λ. The following boundary conditions are prescribed:\n\nv_x = 00 along the top and bottom edges (corners included)\nv_y = 00 on all edges\nbmbarF = 4 bmnu on the left edge\nbmbarF = 8 bmnu on the right edge\n\n\n\n\n\n","category":"function"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.get_f_pull_bc_info","category":"page"},{"location":"man/input/#MembraneAleFem.get_f_pull_bc_info","page":"Input","title":"MembraneAleFem.get_f_pull_bc_info","text":"get_f_pull_bc_info(numnp, IX, bdry_nodes, bdry_inner_nodes, p::Params; args...)\n\nGenerate Mesh data for the flat tube-pulling Scenario F_PULL.\n\nRelevant unknowns are determined via get_dofs, depending on the choice of mesh Motion. The following boundary conditions are prescribed for all mesh motions:\n\nv_z = 0 on all boundaries, and all inner boundaries\nbmbarF = (k_textb  4)bmnu on all boundaries\nv_x = 0, v_y = 0 at center of each edge\nv_x = 0, v_y = 0, v_z = args[:pull_speed]bme_z on nodes of the central element\n\nThe following are prescribed when the Motion is not Lagrangian:\n\nv^textm_x = 0, v^textm_y = 0 at center of each edge\nv^textm_x = 0, v^textm_y = 0, v^textm_z = args[:pull_speed}bme_z on nodes of the central element\n\nThe following are prescribed when the Motion is either ALE-viscous or ALE-viscous-bending:\n\nbmv^textm = bm0 on all boundaries\n\nThe following are prescribed when the Motion is ALE-viscous-bending:\n\nv^textm_z = 0 on all inner boundaries\n\n\n\n\n\n","category":"function"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.get_f_bend_bc_info","category":"page"},{"location":"man/input/#MembraneAleFem.get_f_bend_bc_info","page":"Input","title":"MembraneAleFem.get_f_bend_bc_info","text":"get_f_bend_bc_info(numnp, bdry_nodes, p::Params; args...)\n\nGenerate Mesh data for the flat bending Scenario F_BEND.\n\nRelevant unknowns are determined via get_dofs, depending on the choice of mesh Motion. The following boundary conditions are prescribed for all mesh motions:\n\nLEFT edge:\nbmv = bm0\nM = args[:bend_mf] (see Params.jl)\nif ALE mesh motion: bmv^textm = bm0\nRIGHT edge:\nf_x = 0 and f_y = 0\nv_z = 0\nM = args[:bend_mf] (see Params.jl)\nif ALE mesh motion: v^textm_z = 0\nBOTTOM edge:\nf_x = 0 and f_z = 0\nv_y = 0\nM = 0\nif ALE mesh motion: v^textm_y = 0\nTOP edge:\nf_x = 0 and f_z = 0\nv_y = 0\nM = 0\nif ALE mesh motion: v^textm_y = 0\n\n\n\n\n\n","category":"function"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.get_dofs","category":"page"},{"location":"man/input/#MembraneAleFem.get_dofs","page":"Input","title":"MembraneAleFem.get_dofs","text":"get_dofs(motion::Motion)::Dict{Dof.Unknown, Int64}\n\nReturn global ordering of Unknown degrees of freedom, depending on the mesh Motion.\n\nThe following is the mapping from motion to unknowns:\n\nLagrangian –> v_x, v_y, v_z, λ\nEulerian –> v_x, v_y, v_z, v^textm_x, v^textm_y, v^textm_z, λ\nALE –> v_x, v_y, v_z, v^textm_x, v^textm_y, v^textm_z, λ, p^textm\n\nNote that the flat, 2-D Scenarios (F_CAVI, F_COUE, F_POIS) have a reduced number of degrees of freedom, because there are no unknowns in the z-direction. Thus, this function is not called in those scenarios.\n\n\n\n\n\n","category":"function"},{"location":"man/input/#man-input-jl","page":"Input","title":"Input.jl","text":"","category":"section"},{"location":"man/input/","page":"Input","title":"Input","text":"MembraneAleFem.prepare_input","category":"page"},{"location":"man/input/#MembraneAleFem.prepare_input","page":"Input","title":"MembraneAleFem.prepare_input","text":"prepare_input(p::Params; args...)\n\nGenerate and return the mesh, surface position xms, and Unknown control points cps.\n\nThe mesh is generated by instantiating a Mesh with the provided parameters and arguments, which include the Scenario and number of elements. The surface positions and initial unknowns are set with calls to get_1d_bspline_cps and get_2d_bspline_cps.\n\n\n\n\n\n","category":"function"},{"location":"man/output/#man-output","page":"Output","title":"Output","text":"","category":"section"},{"location":"man/output/","page":"Output","title":"Output","text":"The file src/Output.jl contains the following functions that post-process numerical results.","category":"page"},{"location":"man/output/","page":"Output","title":"Output","text":"generate_state","category":"page"},{"location":"man/output/#MembraneAleFem.generate_state","page":"Output","title":"MembraneAleFem.generate_state","text":"generate_state(path::String, t_id::Int64)\n\nGenerate the membrane state from the given path and time id.\n\n\n\n\n\n","category":"function"},{"location":"man/output/","page":"Output","title":"Output","text":"generate_output","category":"page"},{"location":"man/output/#MembraneAleFem.generate_output","page":"Output","title":"MembraneAleFem.generate_output","text":"generate_output(mesh::Mesh, xms::Matrix{Float64}, cps::Matrix{Float64})\n\nGenerate visualization output for the given mesh, positions, and unknowns.\n\n\n\n\n\n","category":"function"},{"location":"man/output/","page":"Output","title":"Output","text":"analyze_output","category":"page"},{"location":"man/output/#MembraneAleFem.analyze_output","page":"Output","title":"MembraneAleFem.analyze_output","text":"analyze_output(path::String, t_id::Int64)\n\nReturn user-specified information, with which to analyze the chosen data.\n\nCurrently, we do not have separate functions for different scenarios, and so it is up to the user to decide how they would like to analyze their data.\n\n\n\n\n\n","category":"function"},{"location":"man/analysis/#man-analysis","page":"Analysis","title":"Analysis","text":"","category":"section"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"The file src/Analysis.jl and files contained in the src/analysis/ directory are referred to as the analysis module. All finite element analysis is carried out here, including","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"determination of the membrane geometry and dynamics\ncalculation of the residual vector and tangent matrix\nimplementation of Newton–Raphson iteration, and time stepping\ncalculation of the pull force","category":"page"},{"location":"man/analysis/#Overview","page":"Analysis","title":"Overview","text":"","category":"section"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"Though several different mesh motions are implemented, we provide details for only the most involved one: the textttALE-vb mesh motion. At any time step, we begin with the vector of known degrees of freedom mathbfu (t), and seek to calculate the unknown degrees of freedom mathbfu (t + Delta t). In practice, we work primarily with the degrees of freedom corresponding to the various unknowns—in this case, the velocities mathbfv (t), mesh velocities mathbfv^textm (t), surface tensions bmlambda (t), and mesh pressures mathbfp^textm (t).","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"The direct Galerkin expression for the textttALE-vb mesh motion is provided in §2.7.3 of our manuscript (Sahu, 2024). Upon discretization, the direct Galerkin expression is satisfied by solving the set of equations","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"mathbfr^lambda\n =  mathbf0\n\nqquad\nmathbfr^textv\n =  mathbf0\n\nqquad\nmathbfr^textm\n =  mathbf0\n\nqquad\ntextand\nqquad\nmathbfr^textp\n =  mathbf0\n","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"where each vector corresponds to the portion of the residual vector mathbfr associated with a particular unknown. The unknown degree of freedom vector mathbfu (t + Delta t) then satisfies","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"mathbfr ( mathbfu (t + Delta t) ) \n =  mathbf0\n","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"The above equation is solved with the Newton–Raphson method, in which our initial approximation for mathbfu (t + Delta t), denoted mathbfu (t + Delta t)_0, is chosen to be mathbfu (t). Successive approximations are determined according to","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"mathbfu (t + Delta t)_j+1\n =  mathbfu (t + Delta t)_j\n -  mathbfK_j^-1 mathbfr ( mathbfu (t + Delta t)_j ) \n","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"where the global tangent diffusion matrix at the j^textth iteration is given by","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"mathbfK_j\n =  dfracpartial mathbfrpartial mathbfu\nbiggrvert_mathbfu (t + Delta t)_j\n","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"Note that the diffusion matrix is calculated numerically by extending mathbfr and mathbfu into the complex plane [Lyness and Moler (1967), Lyness (1968)]. Details of each portion of our calculation can be found below.","category":"page"},{"location":"man/analysis/#man-geo-dyn-stress","page":"Analysis","title":"GeoDynStress.jl","text":"","category":"section"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"To calculate the residual vector, integrals over the parametric domain are evaluated as the sum of integrals over each finite element. The latter are numerically calculated via Gauss point integration, for which (see GaussPoint.jl and GpBasisFn.jl)","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"int_Omega f(zeta^alpha)  textdOmega\n =  sum_e=1^textttnel int_Omega^e f(zeta^alpha)  textdOmega\n =  sum_e=1^textttnel sum_k=1^textttngp\n\tw_k f(zeta^alpha e_k)\n","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"To simplify such calculations, the struct GeoDynStress contains all quantities at a single Gauss point that are used in the determination of the residual vector. Many of the quantities are self-explanatory; here we describe the few that are not.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"To begin, we use Voigt notation to represent 2×2 matrices as 3×1 vectors, where we take advantage of symmetries in the stresses, couple stresses, and arbitrary variations. Thus,","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"𝞂 is a 3×1 vector containing (σ^1 1 σ^2 2 2 σ^1 2)","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"𝞂m is a 3×1 vector containing (σ^1 1_textm σ^2 2_textm 2 σ^1 2_textm)","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"𝗠 is a 3×1 vector containing (M^1 1 M^2 2 M^1 2 + M^2 1)","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"In addition, we introduce the matrices 𝗕a and 𝗕b containing products of the basis functions with surface geometry. More precisely, we have","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"mathbfB^a\n =  bigg \n\tmathbfB^a_1 \n\tmathbfB^a_2 \n\tldots \n\tmathbfB^a_textnen \nbigg\nqquad\ntextand\nqquad\nmathbfB^b\n =  bigg \n\tmathbfB^b_1 \n\tmathbfB^b_2 \n\tldots \n\tmathbfB^b_textnen \nbigg\n","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"where","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"mathbfB^a_j\n =  beginbmatrix\n\tbma_1^textT N_j 1 4pt\n\tbma_2^textT N_j 2 4pt\n\t(\n\t\tbma_1^textT N_j 2\n\t\t +  bma_2^textT N_j 1\n\t)  2 2pt\nendbmatrix\nqquad\ntextand\nqquad\nmathbfB^b_j\n =  beginbmatrix\n\tbmn^textT N_j 1 1 4pt\n\tbmn^textT N_j 2 2 4pt\n\tbmn^textT  (\n\t\tN_j 1 2\n\t\t +  N_j 2 1\n\t)  2 2pt\nendbmatrix","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"As we will see, determining these quantities greatly simplifies our later finite element calculations.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"GeoDynStress","category":"page"},{"location":"man/analysis/#MembraneAleFem.GeoDynStress","page":"Analysis","title":"MembraneAleFem.GeoDynStress","text":"GeoDynStress(xms, cps, dofs, N, ∂Nα, ∂∂Nαβ, p::Params)\n\nContainer for all geometric, dynamic, and stress-related quantities at a single point (ζ^1 ζ^2).\n\nAccessible fields:\n\ncode symbol\n𝘅 bmx\n𝗮_α bma_α\n∂∂𝘅αβ bmx_ α β\na_αβ a_α β\na△αβ a^α β\n𝗮△α bma^α\nJΩ J_Omega\nΓ△μ_αβ Gamma^mu_alpha beta\n𝗻 bmn\nb_αβ b_α β\nH H\nK K\n𝘃 bmv\n∂𝘃α bmv_ α\n∂∂𝘃αβ bmv_ α β\nλ λ\npm p^textm\n𝘃m bmv^textm\n∂𝘃mα bmv^textm_ α\n∂∂𝘃mαβ bmv^textm_ α β\n𝞂 langle bmsigma rangle\n𝞂m langle bmsigma^textm rangle\n𝗠 langle bmM rangle\n𝗕a mathbfB^a\n𝗕b mathbfB^b\n\n\n\n\n\n","category":"type"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"MembraneAleFem.get_dof_cps","category":"page"},{"location":"man/analysis/#MembraneAleFem.get_dof_cps","page":"Analysis","title":"MembraneAleFem.get_dof_cps","text":"get_dof_cps(cps, dofs, dof_list)\n\nGet control point values for dof_list, which may not be contained in dofs.\n\nAllows one to evaluate various physical quantities (e.g. bmv, λ) even if some of the associated control points are not degrees of freedom—and are thus not solved for.\n\n\n\n\n\n","category":"function"},{"location":"man/analysis/#man-finite-element","page":"Analysis","title":"FiniteElement.jl","text":"","category":"section"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"MembraneAleFem.time_step!","category":"page"},{"location":"man/analysis/#MembraneAleFem.time_step!","page":"Analysis","title":"MembraneAleFem.time_step!","text":"time_step!(mesh, xms, cps, Δt, p::Params; args...)\n\nGiven a known state of the membrane, determine the state a time Δt later.\n\nThe Newton–Raphson method is employed to advance forward in time, which uses the result of calc_r_K.\n\n\n\n\n\n","category":"function"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"MembraneAleFem.calc_r_K","category":"page"},{"location":"man/analysis/#MembraneAleFem.calc_r_K","page":"Analysis","title":"MembraneAleFem.calc_r_K","text":"calc_r_K(mesh, xms, cps, time, Δt, p::Params; args...)\n\nCalculate the residual vector r and diffusion matrix K.\n\nThe global tangent diffusion matrix K is calculated via numerical differentiation, in which the residual vector and its argument are extended into the complex plane Lyness and Moler (1967), Lyness (1968).\n\n\n\n\n\n","category":"function"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"MembraneAleFem.calc_elem_residual","category":"page"},{"location":"man/analysis/#MembraneAleFem.calc_elem_residual","page":"Analysis","title":"MembraneAleFem.calc_elem_residual","text":"calc_elem_residual(mesh, el_id, xms_el, cps_el, p::Params)\n\nCalculate the area element residual vector by looping over Gauss points.\n\n\n\n\n\n","category":"function"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"MembraneAleFem.calc_elem_dof_residuals","category":"page"},{"location":"man/analysis/#MembraneAleFem.calc_elem_dof_residuals","page":"Analysis","title":"MembraneAleFem.calc_elem_dof_residuals","text":"calc_elem_dof_residuals(mesh, el_id, xms_el, cps_el, p::Params)\n\nCalculate the area element residual vectors for each degree of freedom by looping over Gauss points.\n\nThe discretized form of the residual vectors can be read directly from this function.\n\n\n\n\n\n","category":"function"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"MembraneAleFem.calc_bdry_element_residual","category":"page"},{"location":"man/analysis/#MembraneAleFem.calc_bdry_element_residual","page":"Analysis","title":"MembraneAleFem.calc_bdry_element_residual","text":"calc_bdry_element_residual(mesh, bdry, ntype, nval, ..., p::Params; args...)\n\nCalculate the boundary element residual vector by looping over Gauss points.\n\n\n\n\n\n","category":"function"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"MembraneAleFem.update_xms!","category":"page"},{"location":"man/analysis/#MembraneAleFem.update_xms!","page":"Analysis","title":"MembraneAleFem.update_xms!","text":"update_xms!(motion, xms, cps, Δt, dofs)\n\nUpdate membrane positions according to the mesh velocity, using forward Euler.\n\n\n\n\n\n","category":"function"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"MembraneAleFem.calc_τ_ν","category":"page"},{"location":"man/analysis/#MembraneAleFem.calc_τ_ν","page":"Analysis","title":"MembraneAleFem.calc_τ_ν","text":"calc_τ_ν(bdry::Boundary, 𝗮_α::Matrix{ComplexF64}, 𝗻::Vector{ComplexF64})\n\nDetermine the in-plane unit vectors τ and ν on the boundary.\n\n\n\n\n\n","category":"function"},{"location":"man/analysis/#man-pull-force","page":"Analysis","title":"PullForce.jl","text":"","category":"section"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"Specific calculations related to determining the force during tether pulling, as detailed in Appendix C of Sahu (2024).","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"MembraneAleFem.get_pull_el_id","category":"page"},{"location":"man/analysis/#MembraneAleFem.get_pull_el_id","page":"Analysis","title":"MembraneAleFem.get_pull_el_id","text":"get_pull_el_id(numel::Int64)\n\nReturn the id of the element that will be pulled, given the number of elements.\n\n\n\n\n\n","category":"function"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"MembraneAleFem.get_adj_maps","category":"page"},{"location":"man/analysis/#MembraneAleFem.get_adj_maps","page":"Analysis","title":"MembraneAleFem.get_adj_maps","text":"get_adj_maps(num1el::Int64, numel::Int64, IX::Matrix{Int64})\n\nFor each element adjacent to the pulled one, return local ids of pulled nodes.\n\nThese mappings are required to determine the residual vector of pulled nodes, even though the nodes are treated as Dirichlet boundary conditions and thus excluded from the list of degrees of freedom.\n\n\n\n\n\n","category":"function"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"MembraneAleFem.calc_pull_force","category":"page"},{"location":"man/analysis/#MembraneAleFem.calc_pull_force","page":"Analysis","title":"MembraneAleFem.calc_pull_force","text":"calc_pull_force(mesh, xms, cps, adj_el_ids, adj_node_map, p::Params)\n\nReturn the calculated pull force 𝓕, as a 3×1 vector.\n\n\n\n\n\n","category":"function"},{"location":"man/analysis/#man-analysis-jl","page":"Analysis","title":"Analysis.jl","text":"","category":"section"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"MembraneAleFem.run_analysis!","category":"page"},{"location":"man/analysis/#MembraneAleFem.run_analysis!","page":"Analysis","title":"MembraneAleFem.run_analysis!","text":"run_analysis!(mesh, xms, cps, p::Params; args...)\n\nExecute the finite element analysis and step forward in time through args[:Δts].\n\nAt every time step, carry out Newton–Raphson iteration to advance to the next time step. The global residual vector and tangent diffusion matrix are generated at every iteration, and mesh positions are updated according to the mesh velocities.\n\n\n\n\n\n","category":"function"},{"location":"man/overview/#man-overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"In this manual, all paths are provided relative to the root directory MembraneAleFem.jl/. The source code is provided in src/, which contains the following files and folders:","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"$ tree src/\nsrc/\n├── analysis\n│   ├── FiniteElement.jl\n│   ├── GeoDynStress.jl\n│   └── PullForce.jl\n├── Analysis.jl\n├── input\n│   ├── Bc.jl\n│   ├── Dof.jl\n│   ├── Enums.jl\n│   ├── GaussPoint.jl\n│   ├── GpBasisFn.jl\n│   ├── Mesh.jl\n│   ├── Params.jl\n│   └── Spline.jl\n├── Input.jl\n├── MembraneAleFem.jl\n└── Output.jl","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"The function solve in the main program file src/MembraneAleFem.jl carries out all calculations, which are divided into three parts:","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"Input (pre-processing)\nAnalysis (solution)\nOutput (post-processing)","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"We briefly overview the three modules before presenting further details below.","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"src/Input.jl and corresponding files in src/input/ deal with the problem set-up, mesh generation, and degree-of-freedom initialization. Since the parametrization zeta^alpha of the parametric domain Omega subset mathbbR^2 does not change, all basis functions are determined once Omega is initially discretized. We employ B-spline basis functions, as they are well-characterized and satisfy C^1-continuity across finite elements. The local-to-global mapping between elements and degrees of freedom is also determined here.","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"All finite element analysis is carried out in src/Analysis.jl and the files in the src/analysis/ folder. In particular, src/analysis/GeoDynStress.jl takes as arguments the elemental degrees of freedom, and calculates all relevant geometric and dynamic quantities—including the stresses and couple-stresses of the membrane and mesh. The file src/analysis/FiniteElement.jl carries out all finite element analysis, including the calculation of the residual vector and tangent diffusion matrix. src/analysis/PullForce.jl calculates the pull force on a tether, and is thus specific to one of the available scenarios.","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"Currently, src/Output.jl includes a minimal set of functions that process the results of our simulations.","category":"page"},{"location":"man/overview/#man-membrane-ale-fem","page":"Overview","title":"MembraneAleFem.jl","text":"","category":"section"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"The main file src/MembraneAleFem.jl contains a single function, solve(), which then calls relevant functions in the aforementioned files.","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"solve","category":"page"},{"location":"man/overview/#MembraneAleFem.solve","page":"Overview","title":"MembraneAleFem.solve","text":"solve(p::Params; args...)\n\nMain function, which solves any Scenario for the given Parameters.\n\nThe Mesh struct (mesh), initial positions (xms), and initial control points (cps) are first generated by calling prepare_input. With these initial data, run_analysis! is called to solve for the membrane unknowns and positions at a series of discrete times—for which xms and cps are repeatedly updated. Appropriate data is written to output at each time step, and the final mesh, xms and cps are returned.\n\nSee also Scenario, Parameters, Mesh, prepare_input, run_analysis!\n\n\n\n\n\n","category":"function"},{"location":"#Membrane-ALE-FEM","page":"Home","title":"Membrane ALE FEM","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MembraneAleFem.jl solves the continuum equations governing the dynamics of a lipid membrane, using an arbitrary Lagrangian–Eulerian (ALE) finite element method (FEM). In doing so, the surface is discretized and endowed with a mesh whose material behavior and dynamics are arbitrarily specified by the user. The fundamental unknowns are then the material velocity boldsymbolv, mesh velocity boldsymbolv^textm, and surface tension lambda—the latter of which is a Lagrange multiplier that enforces areal incompressibility. Since the mesh motion is arbitrarily specified, we employ another Lagrange multiplier—referred to as the mesh pressure p^textm—to enforce the ALE kinematic constraint","category":"page"},{"location":"","page":"Home","title":"Home","text":"big(\n\tboldsymbolv\n\t -  boldsymbolv^textm\nbig) boldsymbolcdot boldsymboln\n =  0\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"where boldsymboln is the unit normal to the surface. Finally, the position boldsymbolx of the membrane surface is parametrized by the two coordinates zeta^alpha, and determined at the time t from the mesh velocity according to","category":"page"},{"location":"","page":"Home","title":"Home","text":"boldsymbolx (zeta^alpha t)\n =  boldsymbolx (zeta^alpha 0)\n +  int_0^t boldsymbolv^textm (zeta^alpha t)  textd t\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that here and from now on, alpha and other Greek indices span the set {1, 2}. For those also referring to the associated manuscript, in this documentation we drop the 'check' accent over Greek indices for notational convenience.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In employing finite element analysis, we discretize both the temporal and parametric domains. At the time t_n of the n^textth time step, we solve for the finitely many degrees of freedom corresponding to the discretized mesh. Details of our numerical implementation are provided in the manual.","category":"page"},{"location":"#man-cite","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use MembraneAleFem.jl in your work, please reference the following article","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{sahu-arxiv-2024,\n  author  = {A. Sahu},\n  title   = {{Arbitrary Lagrangian--Eulerian finite element method for lipid membranes}},\n  journal = {arXiv preprint},\n  year    = {2024},\n  eprint  = {2412.07596},\n  url     = {https://arxiv.org/abs/2412.07596},\n  archivePrefix={arXiv},\n}","category":"page"},{"location":"#man-install","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Open the Julia REPL, for which you should see the prompt julia>. Then type the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(MembraneAleFem)\nusing MembraneAleFem","category":"page"},{"location":"#man-usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To solve a particular Scenario, one chooses appropriate Parameters and also specifies scenario-specific keyword arguments. The requisite arguments are listed in check_params. In what follows, examples of (1) pure bending and (2) tether pulling are provided. In all cases:","category":"page"},{"location":"","page":"Home","title":"Home","text":"open the Julia REPL\nat the prompt julia>, enter","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MembraneAleFem","category":"page"},{"location":"#Plotting","page":"Home","title":"Plotting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are many ways to plot the calculated results. In the examples presented below, we assume the following has been entered in the REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DelimitedFiles, GLMakie, LaTeXStrings\nGLMakie.activate!();\nset_theme!(theme_latexfonts());","category":"page"},{"location":"#1.-Pure-bending","page":"Home","title":"1. Pure bending","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Calculations","category":"page"},{"location":"","page":"Home","title":"Home","text":"p = Params(motion=LAG, scenario=F_BEND, num1el=2, num2el=2, length=1.);\nmesh, xms, cps = solve(p; bend_tm=2.0, bend_mf=0.5,\n                       t0=0, t0_id=0, Δts=[0.5 for i=1:16],\n                       out_path=\".\", out_file=\"out.txt\");","category":"page"},{"location":"","page":"Home","title":"Home","text":"Plotting","category":"page"},{"location":"","page":"Home","title":"Home","text":"Data files are saved, and can be used to generate a video. Here, we present one way to visualize the final frame from the REPL. The surface color is the error in the surface tension, multiplied by 100.","category":"page"},{"location":"","page":"Home","title":"Home","text":"xout, uout = generate_output(mesh, xms, cps);\n\nfig  = Figure(size=(800, 600));\nga   = fig[1,1] = GridLayout();\nax   = Axis3(ga[1,1], aspect = :data, perspectiveness = 0.2,\n           elevation = 0.5, azimuth = π/2, protrusions = -0);\nsurf = surface!(ax, xout[:,:,1], xout[:,:,2], xout[:,:,3],\n           color = uout[:,:,mesh.dofs[Dof.λ]] .* 10^2 .- 0.25*10^2,\n           colorrange = (-2.0, 2.0), colormap = :roma, shading = NoShading);\n\nhidedecorations!(ax);\nfig","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Pure-bending)","category":"page"},{"location":"#2.-Tether-pulling","page":"Home","title":"2. Tether pulling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Calculations","category":"page"},{"location":"","page":"Home","title":"Home","text":"p = Params(motion=LAG, scenario=F_PULL, num1el=19, num2el=19, length=16.);\nmesh, xms, cps = solve(p; pull_speed=0.5,\n                       t0=0, t0_id=0, Δts=[0.5 for i=1:32],\n                       out_path=\".\", out_file=\"out.txt\");","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pull force","category":"page"},{"location":"","page":"Home","title":"Home","text":"f_pull_data = readdlm(\"f-pull.txt\");\ntether_z = f_pull_data[2:end,4];\ntether_f = f_pull_data[2:end,7];\nscatter(tether_z, tether_f, markersize=15, color=RGBf(0.75, 0.34, 0.0),\n    figure=(;fontsize=32, size=(800, 650)),\n    axis=(; limits = (0, 8, 0, 6.8), aspect=1.2, title=\"Pull Force\",\n          xlabel=L\"z_{\\text{p}}/r_{\\text{c}}\",\n          ylabel=L\"\\mathcal{F}/(k_{\\text{b}}/r_{\\text{c}})\"))","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Force-vs-displacement)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Restart example","category":"page"},{"location":"","page":"Home","title":"Home","text":"To continue tether pulling from its last saved state, run the following code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"mesh, xms, cps = restart(\"params.dat\", \"args.dat\";\n                         in_path=\".\", t0=16.0, t0_id=32, Δts=[0.5 for i=1:12]);","category":"page"},{"location":"#3.-Additional-examples","page":"Home","title":"3. Additional examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For the following Scenarios, we provide only the code to run the calculations; solutions can be plotted by modifying the code above.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Couette flow","category":"page"},{"location":"","page":"Home","title":"Home","text":"p = Params(motion=STATIC, scenario=F_COUE, length=1.0);\nmesh, xms, cps = solve(p; t0=0, t0_id=0, Δts=[1.0], out_path=\".\", out_file=\"out.txt\");","category":"page"},{"location":"","page":"Home","title":"Home","text":"Poiseuille flow","category":"page"},{"location":"","page":"Home","title":"Home","text":"p = Params(motion=STATIC, scenario=F_POIS, length=1.0);\nmesh, xms, cps = solve(p; t0=0, t0_id=0, Δts=[1.0], out_path=\".\", out_file=\"out.txt\");","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lid-driven cavity flow","category":"page"},{"location":"","page":"Home","title":"Home","text":"p = Params(motion=STATIC, scenario=F_CAVI, length=1.0);\nmesh, xms, cps = solve(p; t0=0, t0_id=0, Δts=[1.0], out_path=\".\", out_file=\"out.txt\");","category":"page"},{"location":"#man-outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Overview\nInput\nAnalysis\nOutput","category":"page"},{"location":"#man-references","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Dohrmann, C. R. and Bochev, P. B. (2004). A stabilized finite element method for the Stokes problem based \t             on polynomial pressure projections. Int. J. Numer. Methods Fluids 46, 183–201.\n\n\n\nLyness, J. N. (1968). Differentiation formulas for analytic functions. Math. Comp. 22, 352–362.\n\n\n\nLyness, J. N. and Moler, C. B. (1967). Numerical differentiation of analytic functions. SIAM J. Numer. Anal. 4, 202–210.\n\n\n\nPiegl, L. and Tiller, W. (1997). The NURBS Book. 2nd Edition, Monographs in Visual Communication (Springer-Verlag, Berlin).\n\n\n\nSahu, A. (2024). Arbitrary Lagrangian–Eulerian finite element method for lipid \t           membranes, arXiv preprint, arXiv:2412.07596.\n\n\n\n","category":"page"}]
}
