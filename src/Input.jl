
include("input/Params.jl");
include("input/Spline.jl");
include("input/GaussPoint.jl");
include("input/GpBasisFn.jl");
include("input/Mesh.jl");
include("input/Bc.jl");


"""
    prepare_input(p::Params; args...)

Generate and return the [`mesh`](@ref Mesh), surface position `xms`, and
[`Unknown`](@ref Dof.Unknown) control points `cps`.

The mesh is generated by instantiating a [`Mesh`](@ref) with the provided
parameters and arguments, which include the [`Scenario`](@ref) and number of
elements.
The surface positions and initial unknowns are set with calls to
[`get_1d_bspline_cps`](@ref) and [`get_2d_bspline_cps`](@ref).
"""
function prepare_input(
    p::Params;
    args...
  )

  if p.output
    io = open(args[:out_path] * "/" * args[:out_file], "a");
    println(io, "\nStarting to prepare inputs...");
  end

  mesh = Mesh(p; args...);
  ks   = keys(args);

  if :in_path ∈ ks && :in_xms ∈ ks && :in_cps ∈ ks
    xms  = readdlm(args[:in_path] * "/" * args[:in_xms]);
    cps  = readdlm(args[:in_path] * "/" * args[:in_cps]);

  else

    xms  = zeros(Float64, mesh.numnp, XDIM);      # positions
    cps  = zeros(Float64, mesh.numnp, mesh.ndf);  # control points

    if p.scenario == F_BEND

      xms[:, Int64(Dof.xm)] .=
        get_2d_bspline_cps(mesh.kv1, mesh.kv2, (ζ1, ζ2) -> p.length*ζ1);
      xms[:, Int64(Dof.ym)] .=
        get_2d_bspline_cps(mesh.kv1, mesh.kv2, (ζ1, ζ2) -> p.length*ζ2);
      xms[:, Int64(Dof.zm)] .= 0.0;

      ## add random noise to velocity and mesh velocity initialization
      cps[:, mesh.dofs[Dof.vx]]  .= (rand(mesh.numnp) .- 0.5) / mesh.numel;
      cps[:, mesh.dofs[Dof.vy]]  .= (rand(mesh.numnp) .- 0.5) / mesh.numel;
      cps[:, mesh.dofs[Dof.vz]]  .= rand(mesh.numnp) / mesh.numel;

      if p.motion != LAG
        cps[:, mesh.dofs[Dof.vmx]] .= (rand(mesh.numnp) .- 0.5) / mesh.numel;
        cps[:, mesh.dofs[Dof.vmy]] .= (rand(mesh.numnp) .- 0.5) / mesh.numel;
        cps[:, mesh.dofs[Dof.vmz]] .= rand(mesh.numnp) / mesh.numel;
      end

      ## ensure velocities are zero on boundary
      for bdry ∈ instances(Boundary), i ∈ mesh.bdry_nodes[bdry]
        cps[i, :] .= 0.0;
      end

      ## initialize uniform surface tension (analytical solution)
      λval = p.kb / 4 / p.length^2 * (args[:Δts][1] / args[:bend_tm])^2;
      cps[:, mesh.dofs[Dof.λ]] .= λval;

      if p.output
        println(io, "-> initializing flat patch positions");
        println(io, "-> initializing λ to be ", λval);
      end

    else

      xms[:, Int64(Dof.xm)] .=
        get_2d_bspline_cps(mesh.kv1, mesh.kv2, (ζ1, ζ2) -> p.length*(ζ1-0.5));
      xms[:, Int64(Dof.ym)] .=
        get_2d_bspline_cps(mesh.kv1, mesh.kv2, (ζ1, ζ2) -> p.length*(ζ2-0.5));
      xms[:, Int64(Dof.zm)] .= 0.0;

      λval = p.kb / 4;
      cps[:, mesh.dofs[Dof.λ]] .= λval;

      if p.output
        println(io, "-> initializing flat patch positions");
        println(io, "-> initializing λ to be ", λval);
      end

    end # scenario-specific xms and cps

  end # restart vs new


  # apply inhomogeneous boundary conditions
  if p.output
    println(io, "-> applying inhomogeneous boundary conditions");
  end

  for (unknown, node, value) in mesh.inh_dir_bcs
    cps[node, mesh.dofs[unknown]] = value;
    if p.scenario == F_PULL && p.motion == EUL
      cps[node, mesh.dofs[Dof.vmz]] = value;
    end
  end


  if p.output
    # write initial condition
    writedlm(args[:out_path] * "/t$(args[:t0_id])-xms.txt", xms);
    writedlm(args[:out_path] * "/t$(args[:t0_id])-cps.txt", cps);

    println(io, "Completed preparing inputs...\n");
    close(io);
  end

  return mesh, xms, cps;
end # prepare_input


