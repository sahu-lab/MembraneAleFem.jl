module MembraneAleFem
export Dof, solve, restart

using  LinearAlgebra, SparseArrays, StaticArrays
using  DelimitedFiles, Parameters, Serialization
using  Base.Threads: nthreads, @threads, @spawn
using  Base.Iterators: partition


include("./input/Dof.jl");
include("Input.jl");
include("Analysis.jl");
include("Output.jl");

import .Dof



"""
    solve(p::Params; args...)

Main function, which solves any [`Scenario`](@ref) for the given
[`Parameters`](@ref man-params).

The [`Mesh`](@ref) struct (`mesh`), initial positions (`xms`), and initial
control points (`cps`) are first generated by calling [`prepare_input`](@ref).
With these initial data, [`run_analysis!`](@ref) is called to solve for the
membrane unknowns and positions at a series of discrete times—for which `xms`
and `cps` are repeatedly updated.
Appropriate data is written to output at each time step, and the final `mesh`,
`xms` and `cps` are returned.

See also
[`Scenario`](@ref),
[`Parameters`](@ref man-params),
[`Mesh`](@ref),
[`prepare_input`](@ref),
[`run_analysis!`](@ref)
"""
function solve(
    p::Params;
    args...
  )

  # check and display parameters
  check_params(p; args...); display_params(p; args...);

  # generate mesh, initial position, and initial conditions
  mesh, xms, cps = prepare_input(p; args...);

  # solve for positions and unknowns over time
  run_analysis!(mesh, xms, cps, p; args...);

  # return final membrane state
  return mesh, xms, cps;
end # solve


"""
    restart(p_file::String, a_file::String; r_args...)

Restart a simulation, given past parameters and arguments plus time step info.

The `Params` from the previous run are used once again, as well as the previous
keyword arguments.
Additional arguments can be passed in through `r_args`, and overwrite their
predecessors.
It is required that the set of time steps `Δts`, initial time `t0`, and initial
time ID `t0_id` are passed in again.
"""
function restart(
    p_file::String,
    a_file::String;
    r_args...
  )

  ks     = keys(r_args);
  r_args = Dict(r_args);

  @assert :in_path ∈ ks "\nneed restarting input path 'in_path'";
  @assert :Δts     ∈ ks "\nneed to overwrite 'Δts' during restart";
  @assert :t0_id   ∈ ks "\nneed to overwrite 't0_id' during restart";
  @assert :t0      ∈ ks "\nneed to overwrite 't0' during restart";


  if :in_cps ∉ ks
    r_args[:in_cps]   = "t$(r_args[:t0_id])-cps.txt";
  end
  if :in_xms ∉ ks
    r_args[:in_xms]   = "t$(r_args[:t0_id])-xms.txt";
  end
  if :out_path ∉ ks
    r_args[:out_path] = r_args[:in_path];
  end

  p    = deserialize(r_args[:in_path] * "/" * p_file);
  args = deserialize(r_args[:in_path] * "/" * a_file);

  # add restart arguments to original arguments, with the former overwriting
  args = merge(Dict(args), r_args);

  return solve(p; args...);
end # restart


end # module MembraneAleFem
